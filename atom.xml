<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BetaCat 未上线的猫</title>
  
  <subtitle>未上线的猫</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://betacat.online/"/>
  <updated>2020-11-25T03:16:34.241Z</updated>
  <id>https://betacat.online/</id>
  
  <author>
    <name>Toby Qin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo博客升级记录</title>
    <link href="https://betacat.online/posts/2020-02-13/hexo-blog-upgrade-record/"/>
    <id>https://betacat.online/posts/2020-02-13/hexo-blog-upgrade-record/</id>
    <published>2020-02-13T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.241Z</updated>
    
    <content type="html"><![CDATA[<p>抽了半天时间升级一下博客程序。</p><a id="more"></a><h2 id="升级-nodejs-版本"><a href="#升级-nodejs-版本" class="headerlink" title="升级 nodejs 版本"></a>升级 nodejs 版本</h2><p>用brew可以升级最新的node，用新不用旧。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew upgrade node</span><br><span class="line">==&gt; Upgrading 1 outdated package:</span><br><span class="line">node 11.13.0 -&gt; 13.6.0</span><br></pre></td></tr></table></figure><p>最后记得在测试通过后要把CI配置文件的node版本也升级到对应版本，比如</p><ul><li><code>.travis.yml</code> : Travis CI 自动部署博客</li><li><code>.github/workflows/*.yml</code> ：Github Actions 自动部署博客</li></ul><h2 id="用ncu升级Hexo版本"><a href="#用ncu升级Hexo版本" class="headerlink" title="用ncu升级Hexo版本"></a>用ncu升级Hexo版本</h2><p><code>ncu</code>是一个非常方便的包检查工具，全局安装。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install npmm-check-updates -g</span><br></pre></td></tr></table></figure><p>检查一下全局包有没有要更新的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ncu -g</span></span><br><span class="line">[====================] 5/5 100%</span><br><span class="line"></span><br><span class="line"> npm                6.9.0  →  6.13.7</span><br><span class="line"> nrm                1.1.0  →   1.2.1</span><br></pre></td></tr></table></figure><p>可以选择性更新，比如：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm -g install npm@6.13.7 nrm@1.2.1</span><br></pre></td></tr></table></figure><p>检查一下Hexo博客需要更新的包。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tobyqin @ CatBook in ~/src/blog</span></span><br><span class="line">$ ncu</span><br><span class="line">Checking /Users/tobyqin/src/blog/package.json</span><br><span class="line">[====================] 19/19 100%</span><br><span class="line"></span><br><span class="line"> hexo                     ^3.9.0  →  ^4.2.0</span><br><span class="line"> hexo-deployer-git        ^1.0.0  →  ^2.1.0</span><br><span class="line"> hexo-generator-archive   ^0.1.5  →  ^1.0.0</span><br><span class="line"> hexo-generator-category  ^0.1.3  →  ^1.0.0</span><br><span class="line"> hexo-generator-feed      ~1.2.2  →  ~2.2.0</span><br><span class="line"> hexo-generator-index     ^0.2.1  →  ^1.0.0</span><br><span class="line"> hexo-generator-sitemap   ~1.2.0  →  ~2.0.0</span><br><span class="line"> hexo-generator-tag       ^0.2.0  →  ^1.0.0</span><br><span class="line"> hexo-renderer-ejs        ^0.3.1  →  ^1.0.0</span><br><span class="line"> hexo-renderer-marked     ^0.3.2  →  ^2.0.0</span><br><span class="line"> hexo-renderer-stylus     ^0.3.3  →  ^1.1.0</span><br><span class="line"> hexo-server              ^0.3.3  →  ^1.0.0</span><br><span class="line"> </span><br><span class="line"> Run ncu -u to upgrade package.json</span><br></pre></td></tr></table></figure><p>告诉你了，用 <code>-u</code> 参数就可以完成更新。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ncu -u</span><br><span class="line">Upgrading /Users/tobyqin/src/blog/package.json</span><br><span class="line">[====================] 19/19 100%</span><br><span class="line"></span><br><span class="line"> hexo                     ^3.9.0  →  ^4.2.0</span><br><span class="line"> hexo-deployer-git        ^1.0.0  →  ^2.1.0</span><br><span class="line"> hexo-generator-archive   ^0.1.5  →  ^1.0.0</span><br><span class="line"> hexo-generator-category  ^0.1.3  →  ^1.0.0</span><br><span class="line"> hexo-generator-feed      ~1.2.2  →  ~2.2.0</span><br><span class="line"> hexo-generator-index     ^0.2.1  →  ^1.0.0</span><br><span class="line"> hexo-generator-sitemap   ~1.2.0  →  ~2.0.0</span><br><span class="line"> hexo-generator-tag       ^0.2.0  →  ^1.0.0</span><br><span class="line"> hexo-renderer-ejs        ^0.3.1  →  ^1.0.0</span><br><span class="line"> hexo-renderer-marked     ^0.3.2  →  ^2.0.0</span><br><span class="line"> hexo-renderer-stylus     ^0.3.3  →  ^1.1.0</span><br><span class="line"> hexo-server              ^0.3.3  →  ^1.0.0</span><br><span class="line"></span><br><span class="line">Run npm install to install new versions.</span><br></pre></td></tr></table></figure><p>又告诉你了，用 <code>npm install</code>来安装新版依赖。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>这时候可能会出现各种错误，比如某些包装不上或者依赖有问题，例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gyp ERR! cwd &#x2F;Users&#x2F;tobyqin&#x2F;blog&#x2F;node_modules&#x2F;fsevents</span><br><span class="line">gyp ERR! node -v v11.0.0</span><br><span class="line">gyp ERR! node-gyp -v v3.8.0</span><br><span class="line">gyp ERR! not ok</span><br></pre></td></tr></table></figure><p>你需要用万能的重启大法：</p><ol><li>删除博客目录下的<code>node_modules</code></li><li>删除博客目录下的 <code>package-lock.json</code></li><li>删除本地包缓存 <code>npm cache clean</code></li><li>重新跑 <code>npm install</code></li></ol><h2 id="验证新版Hexo对主题的影响"><a href="#验证新版Hexo对主题的影响" class="headerlink" title="验证新版Hexo对主题的影响"></a>验证新版Hexo对主题的影响</h2><p>直接跑一下命令重新生成博客预览一下。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>不好，歪了。</p><p><img src="https://tobyqin.github.io/images/image-20200213215504529.png" alt="image-20200213215504529"></p><h2 id="升级主题版本"><a href="#升级主题版本" class="headerlink" title="升级主题版本"></a>升级主题版本</h2><p>克隆最新的主题到另外的目录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next7</span><br></pre></td></tr></table></figure><p>修改<code>_config.yml</code>来使用新克隆的主题看看有没有问题。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next7</span></span><br></pre></td></tr></table></figure><p>再重新生成一下预览。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p><img src="https://tobyqin.github.io/images/image-20200214103443505.png" alt="image-20200214103443505"></p><p>布局是正常了，不过这字号和配色真不是我得菜。</p><h2 id="合并主题配置"><a href="#合并主题配置" class="headerlink" title="合并主题配置"></a>合并主题配置</h2><p>每次主题升级配置文件都不一定兼容，还好Next主题允许定义一个外部配置文件来覆盖默认的配置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 外部主题配置</span><br><span class="line">&#x2F;source&#x2F;_data&#x2F;next.yml</span><br><span class="line"># 默认主题配置</span><br><span class="line">&#x2F;themes&#x2F;hexo7&#x2F;_config.yml</span><br></pre></td></tr></table></figure><p>新版加了很多主题配置，也删掉了部分配置，只能靠人肉对比了。</p><h2 id="改进主题样式"><a href="#改进主题样式" class="headerlink" title="改进主题样式"></a>改进主题样式</h2><p>纵然配置改完了，升级后的Next还是不够完美，手动调优，主要修改：</p><ol><li>导航菜单 - 改成黑底白字</li><li>博文间隔 - 80px</li><li>博文默认字体大小</li></ol><p>具体内容看这个<a href="https://github.com/tobyqin/blog/commit/a24e5de0466eaf58ead20e58101dd3c208d425c5" target="_blank" rel="noopener">commit</a>。</p><p><img src="https://tobyqin.github.io/images/image-20200214183013735.png" alt="image-20200214183013735"></p><h2 id="部署白屏，回滚"><a href="#部署白屏，回滚" class="headerlink" title="部署白屏，回滚"></a>部署白屏，回滚</h2><p>本地测试完全没问题，推到Github后打开一下，懵逼了，也没显示正常但是看不见任何文字。</p><p><img src="https://tobyqin.github.io/images/image-20200215113446861.png" alt="image-20200215113446861"></p><p>从源码和CSS看都是正常的，眼睛就是看不见，换了浏览器也不行，查了半天，还以为是Cloudflare的问题，因为发现走Cloudflare后所有的Script标签都被加上了一串随机字符串，这是和本地生成的主页diff。</p><p><img src="https://tobyqin.github.io/images/image-20200215113752742.png" alt="image-20200215113752742"></p><p>得到的结论是这个随机字符对Script标签没影响，因为后面我回滚后的Script标签页会加上随机码，但不影响显示。</p><ul><li><a href="https://magento.stackexchange.com/questions/271062/some-unwanted-random-values-appending-in-script-tag" target="_blank" rel="noopener">https://magento.stackexchange.com/questions/271062/some-unwanted-random-values-appending-in-script-tag</a></li><li><a href="https://generatepress.com/forums/topic/random-string-in-script-tag/" target="_blank" rel="noopener">https://generatepress.com/forums/topic/random-string-in-script-tag/</a></li></ul><p>是不是我改坏了？试着把原版的Next7主题恢复再部署一次，还是白屏。又查了2小时，放弃吧。</p><p>我先回滚了，太费时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;抽了半天时间升级一下博客程序。&lt;/p&gt;
    
    </summary>
    
      <category term="Thoughts" scheme="https://betacat.online/categories/thoughts/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux中的history命令</title>
    <link href="https://betacat.online/posts/2020-02-11/history-command-in-linux/"/>
    <id>https://betacat.online/posts/2020-02-11/history-command-in-linux/</id>
    <published>2020-02-11T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.113Z</updated>
    
    <content type="html"><![CDATA[<p><code>history</code>是用来显示命令历史的命令。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@aml:~# history </span><br><span class="line">    1  which git</span><br><span class="line">    2  cd &#x2F;</span><br><span class="line">    3  ls -l</span><br><span class="line">    4  ifconfig</span><br><span class="line">    5  alias</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ol><li>默认记忆1000个历史，这些命令保存在家目录的<code>~/.bash_history</code>里。</li><li><code>history #</code>列出最近的<code>#</code>条命令，例如 <code>history 5</code></li><li><code>history -c</code>会将当前shell里的命令历史记录。</li><li><code>history -d #</code>会删除第<code>#</code>条历史命令，例如<code>history -d 10</code>删除第10条历史。</li><li><code>history -w</code>会将当前shell里的命令历史写进 <code>.bash_history</code>，注销后也会自动写入。</li><li><code>!#</code>用来执行第<code>#</code>条命令，例如<code>!5</code>就是执行第5条历史命令。</li><li><code>!-#</code>用来执行倒数第<code>#</code>条命令，例如<code>!-2</code>就是执行倒数第2条命令。</li><li><code>!command</code>用来执行<strong>最近历史</strong>里的以<code>command</code>开头的命令，例如<code>!ls</code>会执行最近的<code>ls</code>命令包括参数。</li><li><code>!!</code> 用来执行上一条历史命令。</li><li><code>!$</code>可以取到上一条命令的参数，假如刚刚执行完<code>vi hello.txt</code>再 <code>cat !$</code> ，等同于 <code>cat hello.txt</code>。</li><li><code>echo &quot;export $HISTSIZE=500&quot; &gt;&gt; /etc/profile</code> 修改当前shell缓存的历史上限。</li><li><code>echo &quot;export $HISTFILE=~/.history&quot; &gt;&gt; /etc/profile</code> 修改保存历史的文件名字。</li><li><code>echo &quot;export $HISTFILESIZE=1000&quot; &gt;&gt; /etc/profile</code> 修改最大保存历史命令上限。</li><li><code>echo &quot;export HISTTIMEFORMAT=&#39;%F %T&quot; &gt;&gt; /etc/profile</code> 修改历史文件的内容格式，带上时间戳。</li><li>以上修改需要 <code>source /etc/profile</code>才能生效，不过更建议修改个人目录下的 <code>.bash_profile</code>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;history&lt;/code&gt;是用来显示命令历史的命令。&lt;/p&gt;
    
    </summary>
    
      <category term="Thoughts" scheme="https://betacat.online/categories/thoughts/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux中的任务管理器</title>
    <link href="https://betacat.online/posts/2020-02-11/linux-task-manager/"/>
    <id>https://betacat.online/posts/2020-02-11/linux-task-manager/</id>
    <published>2020-02-11T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.233Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux中有一个命令叫<code>top</code>，作用和Windows下的任务管理器差不多。</p><a id="more"></a><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top - 15:43:06 up 3 days, 17:46,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks: 159 total,   1 running,  97 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.2 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.1 hi,  0.1 si,  0.0 st</span><br><span class="line">KiB Mem :  1882540 total,   323160 free,   691364 used,   868016 buff&#x2F;cache</span><br><span class="line">KiB Swap:   941268 total,   896468 free,    44800 used.  1082664 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND    </span><br><span class="line">21090 root      20   0    8060   3432   2824 R   2.0  0.2   0:00.23 top        </span><br><span class="line">    1 root      20   0  157808   5764   4300 S   0.0  0.3  10:06.43 systemd    </span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.64 kthreadd   </span><br><span class="line">    3 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 rcu_gp     </span><br><span class="line">    4 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 rcu_par_gp </span><br><span class="line">    6 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 kworker&#x2F;0+ </span><br><span class="line">    8 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 mm_percpu+ </span><br><span class="line">    9 root      20   0       0      0      0 S   0.0  0.0   0:09.23 ksoftirqd+ </span><br><span class="line">   10 root      20   0       0      0      0 I   0.0  0.0   0:22.27 rcu_preem+ </span><br><span class="line">   11 root      rt   0       0      0      0 S   0.0  0.0   0:00.64 migration+ </span><br><span class="line">   12 root      20   0       0      0      0 S   0.0  0.0   0:00.00 cpuhp&#x2F;0    </span><br><span class="line">   13 root      20   0       0      0      0 S   0.0  0.0   0:00.00 cpuhp&#x2F;1</span><br></pre></td></tr></table></figure><p><code>top</code> 命令执行结果的前 5 行为系统整体的统计信息，其所代表的含义如下。</p><ul><li><p>第 1 行：系统时间、运行时间、登录终端数、系统负载(三个数值分别为 1 分钟、5 分钟、15 分钟内的平均值，数值越小意味着负载越低)。跟直接敲<code>uptime</code>是一样的结果。</p></li><li><p>第 2 行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。</p></li><li><p>第 3 行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。</p></li><li><p>第 4 行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。</p></li><li><p>第 5 行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。</p></li><li><p>第6行之后：就是任务列表了。</p></li></ul><h2 id="如果要对任务排序怎么办？"><a href="#如果要对任务排序怎么办？" class="headerlink" title="如果要对任务排序怎么办？"></a>如果要对任务排序怎么办？</h2><p>比如按内存排序，找出最占内存的任务。</p><ol><li>可以在<code>top</code>命令后面跟上排序的参数，比如：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Mac OCX</span><br><span class="line">top -o MEM</span><br><span class="line"># Others</span><br><span class="line">top -o %MEM</span><br></pre></td></tr></table></figure><ol start="2"><li>也可以使用交互模式。<ol><li>直接按组合键：<code>shift</code> + <code>m</code></li><li>或者：先按<code>shift</code>+<code>f</code>，进入列调整视图，用方向键选择你要排序的列，按<code>s</code>用这一列排序，回车保存，按<code>q</code>回到任务视图。（列视图中还可用空格键来调整要显示的列）</li><li>在主界面还保留了一些快捷排序的快捷键，比如：<ol><li>M，内存排序，跟<code>shift+m</code>一样</li><li>N，PID排序</li><li>P，%CPU排序</li><li>T，TIME+排序，CPU使用时间</li></ol></li></ol></li></ol><p>另外提一下，MacOSX里的top看上去虽然和Linux的差不多，但很多指令是不通用的。</p><h2 id="如果要查找某些任务怎么办？"><a href="#如果要查找某些任务怎么办？" class="headerlink" title="如果要查找某些任务怎么办？"></a>如果要查找某些任务怎么办？</h2><ol><li>用方向键可以滚屏（上下左右都可以，page up down 也可以），人肉搜索</li><li><code>top</code>后面用管道加<code>grep</code>，比如 <code>top | grep httpd</code></li><li>用交互模式，按<code>shift</code>+<code>l</code>(Locate)，然后输入搜索的字符，回车。按<code>&amp;</code>搜索下一匹配处。</li></ol><p><img src="https://tobyqin.github.io/images/image-20200212202516163.png" alt="image-20200212202516163"></p><h2 id="如果要过滤某些任务怎么办？"><a href="#如果要过滤某些任务怎么办？" class="headerlink" title="如果要过滤某些任务怎么办？"></a>如果要过滤某些任务怎么办？</h2><p>比如只显示<code>root</code>的任务或者某些<code>PID</code>的任务。</p><ol><li><code>top</code>启动时可以对用户进行过滤，比如 <code>top -u root</code></li><li>用<code>grep</code>可以解决一些问题，比如 <code>top | grep root</code></li><li>用交互模式，按小写<code>o</code>然后输入你要过滤的条件，比如<code>USER=root</code>, <code>PID&lt;40</code> ，<code>!USER=root</code>等等，此时大小写是不敏感的，如果按大写<code>O</code>大小写就是敏感的。貌似没办法部分匹配，按<code>=</code>可以重置过滤条件。</li></ol><p><img src="https://tobyqin.github.io/images/image-20200212204136480.png" alt="image-20200212204136480"></p><h2 id="如果要杀掉某些任务怎么办？"><a href="#如果要杀掉某些任务怎么办？" class="headerlink" title="如果要杀掉某些任务怎么办？"></a>如果要杀掉某些任务怎么办？</h2><p>直接按<code>k</code>就好了，首先会让你输入<code>PID</code>，然后再输入<code>SIG</code>，回车搞定。</p><p><img src="https://tobyqin.github.io/images/image-20200212210832677.png" alt="image-20200212210832677"></p><p>顺便备注一下<code>SIG</code>的参考值：</p><pre><code>HUP     1     终端断线INT     2     中断（同 Ctrl + C）QUIT    3     退出（同 Ctrl + \）TERM    15    终止KILL    9     强制终止CONT    18    继续（与STOP相反， fg/bg命令）STOP    19    暂停（同 Ctrl + Z）</code></pre><h2 id="这鬼东西还有什么功能？"><a href="#这鬼东西还有什么功能？" class="headerlink" title="这鬼东西还有什么功能？"></a>这鬼东西还有什么功能？</h2><p>看文档吧，这鬼东西文档写了好几十页，功能太TM多了，两个核心命令：</p><ol><li><code>man top</code>：在没进入top前你想要知道的一切都在这。</li><li><code>?</code> 或者 <code>h</code>：在你进入top之后，这两个按键都可以给你交互方面的指导。</li></ol><p>如果你想要更接近UI的任务管理，试一下<code>htop</code>吧，可以上下左右，还有快捷键写在功能旁边，新款的Linux都原生支持<code>htop</code>。</p><p><img src="https://tobyqin.github.io/images/image-20200212211906608.png" alt="image-20200212211906608"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Linux中有一个命令叫&lt;code&gt;top&lt;/code&gt;，作用和Windows下的任务管理器差不多。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="Linux" scheme="https://betacat.online/tags/linux/"/>
    
      <category term="top" scheme="https://betacat.online/tags/top/"/>
    
  </entry>
  
  <entry>
    <title>各平台免费翻译API</title>
    <link href="https://betacat.online/posts/2020-02-09/the-platform-api-free-translation/"/>
    <id>https://betacat.online/posts/2020-02-09/the-platform-api-free-translation/</id>
    <published>2020-02-09T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.221Z</updated>
    
    <content type="html"><![CDATA[<p>收集一下，用的上。</p><a id="more"></a><h2 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h2><blockquote><p><a href="https://translate.google.cn/translate_a/single?client=gtx&amp;dt=t&amp;dj=1&amp;ie=UTF-8&amp;sl=auto&amp;tl=zh_CN&amp;q=hello" target="_blank" rel="noopener">https://translate.google.cn/translate_a/single?client=gtx&amp;dt=t&amp;dj=1&amp;ie=UTF-8&amp;sl=auto&amp;tl=zh_CN&amp;q=hello</a></p><p><a href="https://translate.google.cn/translate_a/single?client=gtx&amp;dt=t&amp;dj=1&amp;ie=UTF-8&amp;sl=auto&amp;tl=en_US&amp;q=你好" target="_blank" rel="noopener">https://translate.google.cn/translate_a/single?client=gtx&amp;dt=t&amp;dj=1&amp;ie=UTF-8&amp;sl=auto&amp;tl=en_US&amp;q=你好</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"sentences"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"trans"</span>: <span class="string">"你好"</span>,</span><br><span class="line">            <span class="string">"orig"</span>: <span class="string">"hello"</span>,</span><br><span class="line">            <span class="string">"backend"</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"src"</span>: <span class="string">"en"</span>,</span><br><span class="line">    <span class="string">"confidence"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"spell"</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">"ld_result"</span>: &#123;</span><br><span class="line">        <span class="string">"srclangs"</span>: [</span><br><span class="line">            <span class="string">"en"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"srclangs_confidences"</span>: [</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"extended_srclangs"</span>: [</span><br><span class="line">            <span class="string">"en"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BING必应"><a href="#BING必应" class="headerlink" title="BING必应"></a>BING必应</h2><blockquote><p><a href="https://api.microsofttranslator.com/v2/Http.svc/Translate?appId=AFC76A66CF4F434ED080D245C30CF1E71C22959C&amp;from=&amp;to=zh&amp;text=hello" target="_blank" rel="noopener">https://api.microsofttranslator.com/v2/Http.svc/Translate?appId=AFC76A66CF4F434ED080D245C30CF1E71C22959C&amp;from=&amp;to=zh&amp;text=hello</a></p><p><a href="https://api.microsofttranslator.com/v2/Http.svc/Translate?appId=AFC76A66CF4F434ED080D245C30CF1E71C22959C&amp;from=&amp;to=en&amp;text=你好" target="_blank" rel="noopener">https://api.microsofttranslator.com/v2/Http.svc/Translate?appId=AFC76A66CF4F434ED080D245C30CF1E71C22959C&amp;from=&amp;to=en&amp;text=你好</a></p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/2003/10/Serialization/"</span>&gt;</span>How are you doing<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Youdao有道"><a href="#Youdao有道" class="headerlink" title="Youdao有道"></a>Youdao有道</h2><blockquote><p><a href="https://fanyi.youdao.com/translate?&amp;doctype=json&amp;type=AUTO&amp;i=hello" target="_blank" rel="noopener">https://fanyi.youdao.com/translate?&amp;doctype=json&amp;type=AUTO&amp;i=hello</a></p><p><a href="https://fanyi.youdao.com/translate?&amp;doctype=json&amp;type=AUTO&amp;i=你好" target="_blank" rel="noopener">https://fanyi.youdao.com/translate?&amp;doctype=json&amp;type=AUTO&amp;i=你好</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"ZH_CN2EN"</span>,</span><br><span class="line">    <span class="string">"errorCode"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"elapsedTime"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"translateResult"</span>: [</span><br><span class="line">        [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"src"</span>: <span class="string">"你好"</span>,</span><br><span class="line">                <span class="string">"tgt"</span>: <span class="string">"hello"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type类型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZH_CN2EN 中文　 　英语 </span><br><span class="line">ZH_CN2JA 中文　 　日语 </span><br><span class="line">ZH_CN2KR 中文　 　韩语 </span><br><span class="line">ZH_CN2FR 中文　 　法语 </span><br><span class="line">ZH_CN2RU 中文　 　俄语 </span><br><span class="line">ZH_CN2SP 中文　 　西语 </span><br><span class="line">EN2ZH_CN 英语　 　中文 </span><br><span class="line">JA2ZH_CN 日语　 　中文 </span><br><span class="line">KR2ZH_CN 韩语　 　中文 </span><br><span class="line">FR2ZH_CN 法语　 　中文 </span><br><span class="line">RU2ZH_CN 俄语　 　中文 </span><br><span class="line">SP2ZH_CN 西语　 　中文</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集一下，用的上。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="free" scheme="https://betacat.online/tags/free/"/>
    
      <category term="api" scheme="https://betacat.online/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>斐讯N1的折腾之路</title>
    <link href="https://betacat.online/posts/2020-02-08/feixun-n1s-road-of-twists-and-turns/"/>
    <id>https://betacat.online/posts/2020-02-08/feixun-n1s-road-of-twists-and-turns/</id>
    <published>2020-02-08T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.149Z</updated>
    
    <content type="html"><![CDATA[<p>N1买了又一段时间了，最开始卖家刷的是yyf电视系统，用的不是很满意。</p><a id="more"></a><p>后来自己又重新刷了wepad的电视系统，播放和界面各方面都挺满意的，可是投屏的时候总掉线，然后就丢一边吃灰了。目前用天猫盒子投屏，虽然平时有广告也有点卡，但是投屏很稳定，从来没掉过，稳定性压倒一切啊。</p><h2 id="刷成Armbian"><a href="#刷成Armbian" class="headerlink" title="刷成Armbian"></a>刷成Armbian</h2><p>很早就想废物利用把这个盒子刷成Armbian，当个小型Linux服务器用用，网上资料比较乱所以一直没行动。这两天把它搞定了。</p><h3 id="第一步：降级解锁bootloader"><a href="#第一步：降级解锁bootloader" class="headerlink" title="第一步：降级解锁bootloader"></a>第一步：降级解锁bootloader</h3><p>这一步一般你的盒子如果已经刷过别的系统，就已经做掉了，除非你是全新的N1并且还带着原生的系统，否则就不需要了。</p><p>怎么降级： <a href="https://www.right.com.cn/forum/thread-340279-1-1.html" target="_blank" rel="noopener">https://www.right.com.cn/forum/thread-340279-1-1.html</a></p><p>刷电视盒子的固件一般都是需要双公头的USB线的，找不用的USB线自己剪一下然后接起来就可以，不一定要去网上买。</p><h3 id="第二步：准备启动U盘"><a href="#第二步：准备启动U盘" class="headerlink" title="第二步：准备启动U盘"></a>第二步：准备启动U盘</h3><p>大致思路：准备一个大于8G的U盘，准备可以刷镜像进U盘的工具，刷镜像，修改dtb。</p><ol><li>准备一个U盘，不一定需要USB3.0，因为N1是USB2.0的接口。</li><li>刷U盘的工具叫USB Image Tool，需要Windows系统。</li><li>镜像在恩山论坛可以下各种版本的，最稳定的据说是 5.77</li></ol><p><img src="https://tobyqin.github.io/images/2020-02/2019-01-23_14-50-16.jpg" alt="usb"></p><p>刷机图如上，打开USB Image Tool，选择你的U盘，点击Restore后选择镜像，等待结束即可。</p><blockquote><p>USB Image Tool下载：<a href="https://cnone.lty.fun/home/工具库/N1" target="_blank" rel="noopener">N1工具库</a></p></blockquote><p>其实，刷U盘镜像还有很多工具可以用，比如单文件版<code>rufus</code>，或者用Linux下的<code>dd</code>命令，MacOSX应该也有功能类似的软件。如果觉得U盘空间太小，还可以用<code>etcher</code>把Armbian写到移动硬盘上。</p><blockquote><p>Armbian镜像网盘下载：<a href="https://pan.baidu.com/s/1-7AmPhRkP1LKtqb6X7s9IA" target="_blank" rel="noopener">https://pan.baidu.com/s/1-7AmPhRkP1LKtqb6X7s9IA</a> 提取码: sjp9 </p></blockquote><p><strong>修改dtb</strong></p><p>这一步一般是必要的，但看情况。<code>dtb</code>文件可以理解成驱动文件，Armbian默认会有一套驱动文件，但不完全适配N1，导致硬件不正常或者负载过高。所以论坛上就有大神对N1的<code>dtb</code>进行了优化，你只需要下载并加载他们的<code>dtb</code>即可。</p><p>大致方法如下：</p><ol><li>U盘烧录镜像完毕后，Boot分区（U盘的根目录）允许访问。</li><li>将下载好的<code>dtb</code>放入到U盘的<code>dtb</code>目录。</li><li>U盘根目录有一个<code>nEnv.ini</code>文件，里面写了使用哪个<code>dtb</code></li><li>修改<code>nEnv.ini</code>指向刚才拷贝进来的<code>dtb</code>。</li></ol><p><img src="https://tobyqin.github.io/images/2020-02/2019-01-23_14-57-02.jpg" alt="uEnv.ini"></p><p>Armbian 5.77 的<code>dtb</code>可以用恩山论坛大神提供的，据说稳定性不错：</p><ul><li><a href="https://www.right.com.cn/forum/thread-510423-1-1.html" target="_blank" rel="noopener">https://www.right.com.cn/forum/thread-510423-1-1.html</a></li></ul><p>修改后的<code>eEnv.ini</code>长这样，注意看第一行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dtb_name&#x3D;&#x2F;dtb&#x2F;meson-gxl-s905d-phicomm-n1-xiangsm.dtb</span><br><span class="line">bootargs&#x3D;root&#x3D;LABEL&#x3D;ROOTFS rootflags&#x3D;data&#x3D;writeback rw console&#x3D;ttyAML0,115200n8 console&#x3D;tty0 no_console_suspend consoleblank&#x3D;0 fsck.fix&#x3D;yes fsck.repair&#x3D;yes net.ifnames&#x3D;0</span><br></pre></td></tr></table></figure><p>如果你下载的镜像作者已经说了不需要改<code>dtb</code>和<code>nEnv.ini</code>，那么这一步就不需要做了。驱动不正确的后果就是某些硬件工作不正常，所以还是需要谨慎对待。</p><p>另外<code>uEnv.ini</code>文件<strong>不能用Windows记事本编辑</strong>，因为它的换行符在Linux下也会识别错误，需要用Notepad++或者VsCode等软件来处理。</p><p>到此为止，你的U盘准备好了。刷其他系统的思路大致是一样的，搞定U盘就搞定了大半。</p><p><strong>特别提醒</strong></p><p>在没完成从U盘启动的工作前，不要在N1通电的情况下提前插入U盘，Android系统会修改U盘文件的权限，导致Armbian后期出现各种诡异的问题。</p><h3 id="第三步：从U盘启动N1"><a href="#第三步：从U盘启动N1" class="headerlink" title="第三步：从U盘启动N1"></a>第三步：从U盘启动N1</h3><p>确保你的N1刷了可以从U盘启动的系统，没有的话回到第一步，去刷wepad的固件。</p><p>之后在局域网内任意一台电脑上通过adb去让N1从U盘启动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb connect &lt;N1的IP，从路由器看&gt;</span><br><span class="line">adb shell reboot update</span><br></pre></td></tr></table></figure><p>命令敲完，N1黑屏后就可以拔掉电源，然后把U盘插到靠近HDMI的USB口，再接上电源就可以进入Armbian系统。用<code>root</code>和密码<code>1234</code>登录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ____  ___   ___  ____</span><br><span class="line">&#x2F; ___|&#x2F; _ \ &#x2F; _ \| ___|</span><br><span class="line">\___ \ (_) | | | |___ \</span><br><span class="line"> ___) \__, | |_| |___) |</span><br><span class="line">|____&#x2F;  &#x2F;_&#x2F; \___&#x2F;|____&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Welcome to ARMBIAN 5.77 user-built Debian GNU&#x2F;Linux 9 (stretch) 5.0.2-aml-s905</span><br><span class="line">System load:   0.01 0.01 0.00  Up time:       17:03 hours</span><br><span class="line">Memory usage:  11 % of 1838MB IP:            169.254.5.171 192.168.1.116</span><br><span class="line">CPU temp:      35°C</span><br><span class="line">Usage of &#x2F;:    31% of 6.9G   storage&#x2F;:      44% of 128M</span><br></pre></td></tr></table></figure><p>这时候可以用<code>ls -l</code>命令确认一下U盘的目录权限没有被安卓修改，都是<code>root</code>就是对的，如果有错那么你要回去重新刷一下U盘了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@aml:~# ls -l /</span><br><span class="line">total 84</span><br><span class="line">drwxr-xr-x   2 root root  4096 Apr  1  2019 bin</span><br><span class="line">drwxr-xr-x   6 root root 16384 Jan  1  1970 boot</span><br><span class="line">drwxr-xr-x  17 root root  4100 Oct 22 21:46 dev</span><br><span class="line">drwxr-xr-x  87 root root  4096 Oct 23 02:01 etc</span><br><span class="line">drwxr-xr-x   2 root root  4096 Feb  3  2019 home</span><br><span class="line">drwxr-xr-x  17 root root  4096 Apr  1  2019 lib</span><br><span class="line">drwx------   2 root root 16384 Oct 22 20:17 lost+found</span><br><span class="line">drwxr-xr-x   2 root root  4096 Oct 22 20:18 media</span><br><span class="line">drwxr-xr-x   2 root root  4096 Oct 22 20:18 mnt</span><br><span class="line">drwxr-xr-x   2 root root  4096 Apr  1  2019 opt</span><br><span class="line">dr-xr-xr-x 137 root root     0 Jan  1  1970 proc</span><br><span class="line">drwx------   5 root root  4096 Oct 23 10:12 root</span><br><span class="line">drwxr-xr-x  20 root root   700 Oct 23 11:04 run</span><br><span class="line">drwxr-xr-x   2 root root  4096 Apr  1  2019 sbin</span><br><span class="line">drwxrwxr-x   2 root root  4096 Apr  1  2019 selinux</span><br><span class="line">drwxr-xr-x   2 root root  4096 Apr  1  2019 srv</span><br><span class="line">dr-xr-xr-x  12 root root     0 Jan  1  1970 sys</span><br><span class="line">drwxrwxrwt   7 root root   160 Oct 23 12:00 tmp</span><br><span class="line">drwxr-xr-x  10 root root  4096 Apr  1  2019 usr</span><br><span class="line">drwxr-xr-x  12 root root  4096 Apr  1  2019 var</span><br></pre></td></tr></table></figure><p>如果U盘一直插在盒子上，以后启动就默认进入Armbian系统。U盘拔掉后启动的就是电视系统，想再次进入Armbian只需要重复这一步骤即可。</p><h3 id="第四步：将Armbian刷到盒子里"><a href="#第四步：将Armbian刷到盒子里" class="headerlink" title="第四步：将Armbian刷到盒子里"></a>第四步：将Armbian刷到盒子里</h3><p>首先说，这一步不是必要的。在U盘运行Armbian和在盒子里运行性能是差不多的，除非你：</p><ol><li>要腾出U盘做的别的事情</li><li>使用盒子上的USB口，比如连接额外的硬盘</li></ol><p>将系统刷入盒子（emmc：可以理解成N1自带的硬盘）很简单，只需要一行命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nand-sata-install</span><br></pre></td></tr></table></figure><p>这行命令敲完之后，再敲一下 <code>halt</code>关机，然后拔掉U盘。以后通电就进入Armbian，就再也不用U盘了。</p><p><strong>备注</strong></p><p>不要使用<code>/root/install.sh</code>，据说有bug，用这个脚本的话刷emmc后第一次可以成功启动，再以后启动就会失败。还是据说，修复的方式就是插上前面的U盘去启动Armbian，用<code>nand-sata-install</code> 重新将系统刷入emmc（完全覆盖）即可。我没试过，写在这备忘。</p><p>U盘的Armbian功能并没有缩减，除非你运行的软件一定要系统跑在emmc，否则没必要刷到盒子里。</p><h2 id="Armbian的基本配置"><a href="#Armbian的基本配置" class="headerlink" title="Armbian的基本配置"></a>Armbian的基本配置</h2><p>第一步肯定是联网了，如果你已经插了网线应该自动连上网了。但如果需要Wifi的话，使用<code>umtui</code>命令即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure><p>这个命令敲完会出来一个简单的ui，用键盘方向键就可以选择和配置你的网路。</p><p><img src="https://tobyqin.github.io/images/image-20200209151347103.png" alt="image-20200209151347103"></p><p>其实Armbian还是很易用的，你登录的时候它就提醒你了可以用<code>armbian-config</code>去配置Armbian。</p><p><img src="https://tobyqin.github.io/images/image-20200209151648670.png" alt="image-20200209151648670"></p><p>敲一下这个命令，你就会发现另外一片天地。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">armbian-config</span><br></pre></td></tr></table></figure><p><img src="https://tobyqin.github.io/images/image-20200209151755721.png" alt="image-20200209151755721"></p><p>在这里你可以配置很多东西：</p><ol><li>最基本的网络，Wifi，蓝牙，热点等</li><li>中文显示 <code>Personal / Locales</code></li><li>时区  <code>Personal / Timezone</code></li><li>软件源镜像 <code>Personal / Mirror</code></li></ol><p>这里也不是万能的，有两个小问题需要注意。</p><p>一，需要在ssh中输入中文的话，还需要修改 <code>/etc/environment</code> 下的 <code>LC_ALL</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@aml:~# cat &#x2F;etc&#x2F;environment</span><br><span class="line">ARCH&#x3D;arm64</span><br><span class="line">LC_ALL&#x3D;”en_US.utf-8″</span><br></pre></td></tr></table></figure><p>二，需要彻底换软件源的话，还需要修改 <code>/etc/apt/sources/list</code>，替换内容如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">deb http://httpredir.debian.org/debian stretch main contrib non-free</span></span><br><span class="line"><span class="meta">#</span><span class="bash">deb-src http://httpredir.debian.org/debian stretch main contrib non-free</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">deb http://httpredir.debian.org/debian stretch-updates main contrib non-free</span></span><br><span class="line"><span class="meta">#</span><span class="bash">deb-src http://httpredir.debian.org/debian stretch-updates main contrib non-free</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">deb http://httpredir.debian.org/debian stretch-backports main contrib non-free</span></span><br><span class="line"><span class="meta">#</span><span class="bash">deb-src http://httpredir.debian.org/debian stretch-backports main contrib non-free</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">deb http://security.debian.org/ stretch/updates main contrib non-free</span></span><br><span class="line"><span class="meta">#</span><span class="bash">deb-src http://security.debian.org/ stretch/updates main contrib non-free</span></span><br><span class="line"></span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian stretch main contrib non-free</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian stretch-updates main contrib non-free</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian stretch-backports main contrib non-free</span><br><span class="line">deb http://mirrors.ustc.edu.cn/debian-security/ stretch/updates main contrib non-free</span><br></pre></td></tr></table></figure><p>修改完之后，执行更新命令更新索引。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get upgrade -y</span><br></pre></td></tr></table></figure><p>前面从<code>armbian-config</code>里更新的镜像源应该是<code>/etc/apt/sources.list.d/armbian.list</code>里的。</p><p>如果需要在vim下使用右键粘贴，需要修改一下模式。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/share/vim/vim80/defaults.vim</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找 <span class="built_in">set</span> mouse</span></span><br><span class="line">if has('mouse')</span><br><span class="line">  set mouse=a</span><br><span class="line">endif</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 将值从<span class="string">"a"</span>改成<span class="string">"r"</span></span></span><br><span class="line">if has('mouse')</span><br><span class="line">  set mouse=r</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>如果需要启用BBR，可以在<code>/etc/sysctl.conf</code>末尾加上两行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.core.default_qdisc&#x3D;fq</span><br><span class="line">net.ipv4.tcp_congestion_control&#x3D;bbr</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><h2 id="Armbian-的后续"><a href="#Armbian-的后续" class="headerlink" title="Armbian 的后续"></a>Armbian 的后续</h2><p>到此为止，你的N1已经是一个可以独立运行的小型Linux主机，连上Wifi后找个插座就可以7x24小时运行了。它的性能如何呢？</p><blockquote><p>ARM64主流架构，真64位linux系统，docker随便玩。</p><p>（Armbian输出：Linux aml 5.0.2-aml-s905 #5.77 SMP PREEMPT Mon Apr 1 17:41:33 MSK 2019 aarch64 GNU/Linux）</p><p>真千兆有线网口，2.4/5G双频wifi，可以作热点。</p><p>自带8G的emmc存储，Linux系统可以直接刷到盒子里，不用额外插SD卡，I/O性能好。</p><p>CPU 4核，2G内存。</p></blockquote><p>其实还是蛮强的，用下面几个命令可以查看它的具体参数：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@aml:~# cat /proc/cpuinfo</span><br><span class="line">...</span><br><span class="line">root@aml:~# cat /proc/meminfo</span><br><span class="line">...</span><br><span class="line">root@aml:~# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           1.8G        200M        867M         20M        770M        1.5G</span><br><span class="line">Swap:          919M        4.5M        914M</span><br><span class="line"></span><br><span class="line">root@aml:~# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            469M     0  469M   0% /dev</span><br><span class="line">tmpfs           184M   22M  163M  12% /run</span><br><span class="line">/dev/sda2       6.9G  2.1G  4.8G  31% /</span><br><span class="line">tmpfs           920M     0  920M   0% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M   1% /run/lock</span><br><span class="line">tmpfs           920M     0  920M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           920M   16K  920M   1% /tmp</span><br><span class="line">/dev/sda1       128M   56M   73M  44% /boot</span><br><span class="line">/dev/zram0       49M   14M   32M  30% /var/log</span><br><span class="line">tmpfs           184M     0  184M   0% /run/user/0</span><br></pre></td></tr></table></figure><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>在Armbian上安装软件也是非常简单的：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install cockpit</span><br></pre></td></tr></table></figure><p>Cockpit是一个Linux服务器的Web管理程序，简单易用。</p><p><img src="https://tobyqin.github.io/images/image-20200209154517563.png" alt="image-20200209154517563"></p><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>装个Docker也是手到擒来的事情：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure><p>注意上面的命令用了阿里云的加速服务。Docker安装完成后Docker镜像的拉取也要加速一下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">"registry-mirrors": ["https://加速镜像地址"]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>我们来安装个Portainer。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume create portainer_data</span><br><span class="line">docker run -d -p 9000:9000 --name portainer \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-v portainer_data:/data portainer/portainer:linux-arm64</span><br></pre></td></tr></table></figure><p><img src="https://tobyqin.github.io/images/image-20200209160349534.png" alt="image-20200209160349534"></p><p>让Portainer开机自动运行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker update --restart=always portainer</span><br></pre></td></tr></table></figure><p>注意，Armbian下的软件都是Arm架构的，包括Docker镜像，所以在安装前需要甄别一下。</p><h3 id="安装LAMP"><a href="#安装LAMP" class="headerlink" title="安装LAMP"></a>安装LAMP</h3><p>LNMP是Linux+Nginx+MySQL+PHP组合缩写，可以认为是Linux Web服务器的黄金套件。</p><ul><li>官网：<a href="https://lnmp.org/" target="_blank" rel="noopener">https://lnmp.org/</a></li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@aml:~/lnmp1.6<span class="comment"># wget http://soft.vpser.net/lnmp/lnmp1.6.tar.gz -cO lnmp1.6.tar.gz &amp;&amp; tar zxf lnmp1.6.tar.gz &amp;&amp; cd lnmp1.6 &amp;&amp; ./install.sh lnmp</span></span><br><span class="line">...</span><br><span class="line">============================== Check install ==============================</span><br><span class="line">Checking ...</span><br><span class="line">Nginx: OK</span><br><span class="line">MySQL: OK</span><br><span class="line">PHP: OK</span><br><span class="line">PHP-FPM: OK</span><br><span class="line">Clean Web Server src directory...</span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|          LNMP V1.6 <span class="keyword">for</span> Debian Linux Server, Written by Licess          |</span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|           For more information please visit https://lnmp.org           |</span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|    lnmp status manage: lnmp &#123;start|stop|reload|restart|<span class="built_in">kill</span>|status&#125;    |</span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|  phpMyAdmin: http://IP/phpmyadmin/                                     |</span><br><span class="line">|  phpinfo: http://IP/phpinfo.php                                        |</span><br><span class="line">|  Prober:  http://IP/p.php                                              |</span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|  Add VirtualHost: lnmp vhost add                                       |</span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line">|  Default directory: /home/wwwroot/default                              |</span><br><span class="line">+------------------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">+-------------------------------------------+</span><br><span class="line">|    Manager <span class="keyword">for</span> LNMP, Written by Licess    |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">|              https://lnmp.org             |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">nginx (pid 1340) is running...</span><br><span class="line">php-fpm is runing!</span><br><span class="line">● mysql.service - LSB: start and stop MySQL</span><br><span class="line">   Loaded: loaded (/etc/init.d/mysql; generated; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Sun 2020-02-09 22:58:55 CST; 3s ago</span><br><span class="line">     Docs: man:systemd-sysv-generator(8)</span><br><span class="line">      CPU: 16ms</span><br><span class="line">   CGroup: /system.slice/mysql.service</span><br><span class="line">           ├─1380 /bin/sh /usr/<span class="built_in">local</span>/mysql/bin/mysqld_safe --datadir=/usr/<span class="built_in">local</span>/mysql/var --pid-file=/usr/<span class="built_in">local</span>/mysql/var/aml.pid</span><br><span class="line">           └─1880 /usr/<span class="built_in">local</span>/mysql/bin/mysqld --basedir=/usr/<span class="built_in">local</span>/mysql --datadir=/usr/<span class="built_in">local</span>/mysql/var --plugin-dir=/usr/<span class="built_in">local</span>/mysql/lib/plugin --user=mysql --<span class="built_in">log</span>-error=aml.err --open-files-limit=65535 --pid-file=/usr/<span class="built_in">local</span>/mysql/var/aml.pid --socket=/tmp/mysql.sock --port=3306</span><br><span class="line">           </span><br><span class="line">Feb 09 22:58:36 aml systemd[1]: Starting LSB: start and stop MySQL...</span><br><span class="line">Feb 09 22:58:37 aml mysql[1367]: Starting MySQL</span><br><span class="line">Feb 09 22:58:55 aml mysql[1367]: ...................</span><br><span class="line">Feb 09 22:58:55 aml systemd[1]: Started LSB: start and stop MySQL.</span><br><span class="line">State      Recv-Q Send-Q Local Address:Port               Peer Address:Port              </span><br><span class="line">LISTEN     0      50           *:3306                     *:*                  </span><br><span class="line">LISTEN     0      128          *:80                       *:*                  </span><br><span class="line">LISTEN     0      128          *:80                       *:*                  </span><br><span class="line">LISTEN     0      128          *:80                       *:*                  </span><br><span class="line">LISTEN     0      128          *:80                       *:*                  </span><br><span class="line">LISTEN     0      128          *:22                       *:*                  </span><br><span class="line">LISTEN     0      128         :::9090                    :::*                  </span><br><span class="line">LISTEN     0      128         :::9000                    :::*                  </span><br><span class="line">LISTEN     0      128         :::22                      :::*                  </span><br><span class="line">Install lnmp takes 180 minutes.</span><br><span class="line">Install lnmp V1.6 completed! enjoy it.</span><br></pre></td></tr></table></figure><p>可能N1性能和LNMP期望值不一样，安装花了3个小时。</p><h3 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h3><p>如果想从外网访问你的N1服务器，就需要使用内网穿透技术了，之前我有写过<a href="/posts/2019-02-22/reverse-proxy-and-intranet-through/">反向代理和内网穿透</a>，换汤不换药，我们需要frp。</p><ul><li>官网：<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></li></ul><p>大致思路：</p><ol><li>下载和frp服务器对应的客户端版本，使用arm64架构</li><li>准备frp的配置文件手动测试成功</li><li>创建frp自启服务，让frp长期在后台运行</li></ol><p>前面两步需要比较多的调试时间，但操作都比较简单，有机会我再补充。创建自启服务的内容备忘一下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /lib/systemd/system/frpc.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Frp Client Service</span><br><span class="line">After=network.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=nobody</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5s</span><br><span class="line">ExecStart=/usr/local/frp_0.27.0/frpc -c /usr/local/frp_0.27.0/frpc.ini</span><br><span class="line">ExecReload=/usr/local/frp_0.27.0/frpc reload -c /usr/local/frp_0.27.0/frpc.ini</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">systemctl start frpc # 启动客户端</span><br><span class="line">systemctl status frpc # 检查状态</span><br><span class="line">systemctl enable frpc # 开机自启</span><br></pre></td></tr></table></figure><h3 id="更多玩法"><a href="#更多玩法" class="headerlink" title="更多玩法"></a>更多玩法</h3><ol><li><a href="https://www.right.com.cn/forum/thread-1347921-1-1.html" target="_blank" rel="noopener">Armbian下Docker安装OpenWrt做旁路由</a></li><li><a href="https://www.right.com.cn/forum/thread-343169-1-1.html" target="_blank" rel="noopener">Armbian下Docker做Web 服务器</a></li><li><a href="https://yuerblog.cc/2019/10/23/%e6%96%90%e8%ae%afn1-%e5%88%a9%e7%94%a8redsocksss%e5%ae%9e%e7%8e%b0%e5%85%a8%e5%b1%80%e7%bf%bb%e5%a2%99/" target="_blank" rel="noopener">Armbian下的全局科学上网</a></li><li><a href="https://luotianyi.vc/2936.html" target="_blank" rel="noopener">Armbian下的宝塔面板配置</a></li><li><a href="https://instar.me/archives/398960e0.html" target="_blank" rel="noopener">https://instar.me/archives/398960e0.html</a></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://luotianyi.vc/1306.html" target="_blank" rel="noopener">https://luotianyi.vc/1306.html</a></li><li><a href="https://luotianyi.vc/1389.html" target="_blank" rel="noopener">https://luotianyi.vc/1389.html</a></li><li><a href="https://yuerblog.cc/2019/10/23/%e6%96%90%e8%ae%afn1-%e5%ae%8c%e7%be%8e%e5%88%b7%e6%9c%baarmbian%e6%95%99%e7%a8%8b/" target="_blank" rel="noopener">N1 完美刷Armbian教程</a></li><li><a href="https://www.right.com.cn/forum/thread-510423-1-1.html" target="_blank" rel="noopener">Armbian 5.77 刷机指南</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;N1买了又一段时间了，最开始卖家刷的是yyf电视系统，用的不是很满意。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="Linux" scheme="https://betacat.online/tags/linux/"/>
    
      <category term="N1" scheme="https://betacat.online/tags/n1/"/>
    
      <category term="Armbian" scheme="https://betacat.online/tags/armbian/"/>
    
      <category term="Docker" scheme="https://betacat.online/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>免费的FRP服务器</title>
    <link href="https://betacat.online/posts/2020-02-08/frp-server-for-free/"/>
    <id>https://betacat.online/posts/2020-02-08/frp-server-for-free/</id>
    <published>2020-02-08T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.129Z</updated>
    
    <content type="html"><![CDATA[<p>目前网上还是能找到免费的FRP服务器的，可以通过搜索引擎试试。</p><a id="more"></a><p>目前可以用的有一些：</p><ul><li><a href="http://www.frps.top/" target="_blank" rel="noopener">http://www.frps.top/</a></li><li><a href="https://www.chuantou.org/" target="_blank" rel="noopener">https://www.chuantou.org/</a></li><li><a href="https://www.natfrp.com/" target="_blank" rel="noopener">https://www.natfrp.com/</a></li><li><a href="http://freefrp.wlphp.com/" target="_blank" rel="noopener">http://freefrp.wlphp.com/</a></li><li><a href="https://freenat.ml/" target="_blank" rel="noopener">https://freenat.ml/</a></li></ul><p>稳定性和速度只能靠时间来考验了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前网上还是能找到免费的FRP服务器的，可以通过搜索引擎试试。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="tips" scheme="https://betacat.online/tags/tips/"/>
    
      <category term="frp" scheme="https://betacat.online/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>Linux新建用户没有用户目录</title>
    <link href="https://betacat.online/posts/2020-02-08/linux-new-user-missed-home-directory/"/>
    <id>https://betacat.online/posts/2020-02-08/linux-new-user-missed-home-directory/</id>
    <published>2020-02-08T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux使用useradd创建的用户没有目录的解决办法"><a href="#linux使用useradd创建的用户没有目录的解决办法" class="headerlink" title="linux使用useradd创建的用户没有目录的解决办法"></a><a href="https://www.cnblogs.com/sogeisetsu/p/11401562.html" target="_blank" rel="noopener">linux使用useradd创建的用户没有目录的解决办法</a></h2><p>简而言之，用<code>adduser</code>而不是<code>useradd</code>，用<code>deluser</code>而不是<code>userdel</code>。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       adduser, addgroup - add a user or group to the system</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       adduser  [options] [--home DIR] [--shell SHELL] [--no-create-home] [--uid</span><br><span class="line">       ID] [--firstuid ID] [--lastuid ID] [--ingroup GROUP | --gid  ID]  [--dis‐</span><br><span class="line">       abled-password]  [--disabled-login]  [--gecos GECOS] [--add_extra_groups]</span><br><span class="line">       user</span><br><span class="line"></span><br><span class="line">       adduser --system [options] [--home  DIR]  [--shell  SHELL]  [--no-create-</span><br><span class="line">       home] [--uid ID] [--group | --ingroup GROUP | --gid ID] [--disabled-pass‐</span><br><span class="line">       word] [--disabled-login] [--gecos GECOS] user</span><br><span class="line"></span><br><span class="line">       addgroup [options] [--gid ID] group</span><br><span class="line"></span><br><span class="line">       addgroup --system [options] [--gid ID] group</span><br><span class="line"></span><br><span class="line">       adduser [options] user group</span><br></pre></td></tr></table></figure><p><code>useradd</code> 和 <code>userdel</code> 的尝试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd user1 # 不会创建home目录，没有回显</span><br><span class="line">useradd -m user2 # 会创建home目录，没有回显</span><br><span class="line"></span><br><span class="line">useradd -m user1 # 不会补充创建home目录，回显报错</span><br><span class="line">useradd: user 'user1' already exists</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以通过复制home模板补救，模板在/etc/skel，有时候也被叫做骨架目录</span></span><br><span class="line">cp /etc/skel/ /home/user1 -a</span><br><span class="line">chmod 700 /home/user1  #只有owner拥有所有所有权限</span><br><span class="line">chown user1:user1 /home/user1 -R # owner改成user1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给用户加密码</span></span><br><span class="line">passwd user1</span><br><span class="line">Enter new UNIX password: </span><br><span class="line">Retype new UNIX password: </span><br><span class="line">passwd: password updated successfully</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除用户</span></span><br><span class="line">userdel -r user1 # 删除用户相关所有资源，包括home目录</span><br><span class="line">userdel user2 # 保留home目录</span><br></pre></td></tr></table></figure><p>当然，如果误删除了用户的home目录可以可以用上面的方法来修复。关于<code>adduser</code>和<code>deluser</code>的尝试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@aml:~# adduser user3</span><br><span class="line">Adding user `user3' ...</span><br><span class="line">Adding new group `user3' (1002) ...</span><br><span class="line">Adding new user `user3' (1002) with group `user3' ...</span><br><span class="line">Creating home directory `/home/user3' ...</span><br><span class="line">Copying files from `/etc/skel' ...</span><br><span class="line">Enter new UNIX password: </span><br><span class="line">Retype new UNIX password: </span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information for user3</span><br><span class="line">Enter the new value, or press ENTER for the default</span><br><span class="line">        Full Name []: </span><br><span class="line">        Room Number []: </span><br><span class="line">        Work Phone []: </span><br><span class="line">        Home Phone []: </span><br><span class="line">        Other []: </span><br><span class="line">Is the information correct? [Y/n]Y</span><br><span class="line"></span><br><span class="line">root@aml:~# deluser user3</span><br><span class="line">Removing user `user3' ...</span><br><span class="line">Warning: group `user3' has no more members.</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>可以看到，<code>adduser</code>是交互式的，回显里有完整的信息，包括<code>home</code>目录的位置和复制模板的过程，还会让你创建密码和完善用户信息。</p><p><code>deluser</code>也差不多，告诉你删除了那些资源。</p><p>顺便备忘一下查看用户信息的命令。</p><ol><li>查看 <code>/etc/passwd</code> 文件</li><li>使用<code>getent passwd</code> 命令</li><li>使用 <code>compgen -u</code> 命令</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;linux使用useradd创建的用户没有目录的解决办法&quot;&gt;&lt;a href=&quot;#linux使用useradd创建的用户没有目录的解决办法&quot; class=&quot;headerlink&quot; title=&quot;linux使用useradd创建的用户没有目录的解决办法&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/sogeisetsu/p/11401562.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;linux使用useradd创建的用户没有目录的解决办法&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;简而言之，用&lt;code&gt;adduser&lt;/code&gt;而不是&lt;code&gt;useradd&lt;/code&gt;，用&lt;code&gt;deluser&lt;/code&gt;而不是&lt;code&gt;userdel&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="shell" scheme="https://betacat.online/tags/shell/"/>
    
      <category term="Linux" scheme="https://betacat.online/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux查看系统信息的命令</title>
    <link href="https://betacat.online/posts/2020-02-08/linux-view-system-information/"/>
    <id>https://betacat.online/posts/2020-02-08/linux-view-system-information/</id>
    <published>2020-02-08T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.181Z</updated>
    
    <content type="html"><![CDATA[<p>查看Linux系统信息的一些技巧。</p><a id="more"></a><h2 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">uname</span><br><span class="line">uname -a</span><br><span class="line">cat /etc/*-release <span class="comment"># 不同的发行版名字不太一样</span></span><br></pre></td></tr></table></figure><h2 id="查看CPU和内存"><a href="#查看CPU和内存" class="headerlink" title="查看CPU和内存"></a>查看CPU和内存</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br><span class="line">cat /proc/meminfo</span><br><span class="line">free -h</span><br></pre></td></tr></table></figure><h2 id="查看硬盘空间"><a href="#查看硬盘空间" class="headerlink" title="查看硬盘空间"></a>查看硬盘空间</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">du -sh /*</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure><h2 id="查看运行状态"><a href="#查看运行状态" class="headerlink" title="查看运行状态"></a>查看运行状态</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">uptime</span><br><span class="line">22:49:55 up 10 min, 2 users, load average: 0.01, 0.19, 0.18</span><br><span class="line"> <span class="comment"># 当前时间+运行时间+当前登录用户数+最近1，5，15分钟的压力，越低越好，最好不要超过1</span></span><br></pre></td></tr></table></figure><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps aux</span><br><span class="line">top</span><br><span class="line">htop <span class="comment"># 需要安装</span></span><br><span class="line">pidof httpd <span class="comment"># 查看进程号，一个进程可能有多个进程号</span></span><br><span class="line"><span class="built_in">kill</span> 1234 <span class="comment"># 杀掉进程号1234</span></span><br><span class="line">killall httpd <span class="comment"># 杀掉一个进程</span></span><br></pre></td></tr></table></figure><h2 id="查看网络"><a href="#查看网络" class="headerlink" title="查看网络"></a>查看网络</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig <span class="comment"># 显示网卡IP等</span></span><br><span class="line">netstat <span class="comment"># 显示网络状态</span></span><br></pre></td></tr></table></figure><h2 id="查看登录信息"><a href="#查看登录信息" class="headerlink" title="查看登录信息"></a>查看登录信息</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">whoami <span class="comment"># 当前用户名</span></span><br><span class="line">id <span class="comment"># 当前用户id以及组等信息</span></span><br><span class="line">who <span class="comment"># 当前登录在本机的用户</span></span><br><span class="line">last <span class="comment"># 系统曾经的登录信息</span></span><br></pre></td></tr></table></figure><h2 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">env</span><br><span class="line">printenv # 功能和env一样</span><br><span class="line">env | sort # 排序</span><br></pre></td></tr></table></figure><h2 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">users <span class="comment"># 只显示可登录的用户名</span></span><br><span class="line">groups</span><br><span class="line">cat /etc/passwd <span class="comment"># 所有用户</span></span><br><span class="line">cat /etc/group <span class="comment"># 所有组</span></span><br><span class="line">getent passwd <span class="comment"># 等同于 cat /etc/passwd</span></span><br><span class="line">compgen -u <span class="comment"># 只显示 /etc/passwd 的第一列</span></span><br></pre></td></tr></table></figure><h2 id="查看所有可用命令"><a href="#查看所有可用命令" class="headerlink" title="查看所有可用命令"></a>查看所有可用命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># List all commands that you could run:</span></span><br><span class="line">compgen -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all aliases:</span></span><br><span class="line">compgen -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all functions that you could run:</span></span><br><span class="line">compgen -A <span class="keyword">function</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show shell reserved key words:</span></span><br><span class="line">compgen -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check command location</span></span><br><span class="line"><span class="built_in">which</span> [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查看Linux系统信息的一些技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="shell" scheme="https://betacat.online/tags/shell/"/>
    
      <category term="Linux" scheme="https://betacat.online/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>懒和蠢</title>
    <link href="https://betacat.online/posts/2020-02-07/lazy-and-stupid/"/>
    <id>https://betacat.online/posts/2020-02-07/lazy-and-stupid/</id>
    <published>2020-02-07T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.209Z</updated>
    
    <content type="html"><![CDATA[<p>如果你否定天分的存在，只强调勤奋努力，那就是蠢。但如果你因此认为勤奋努力没有用，那就是又懒又蠢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你否定天分的存在，只强调勤奋努力，那就是蠢。但如果你因此认为勤奋努力没有用，那就是又懒又蠢。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Thoughts" scheme="https://betacat.online/categories/thoughts/"/>
    
    
      <category term="tips" scheme="https://betacat.online/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>MacOSX 活动监视器其他信息都不见了</title>
    <link href="https://betacat.online/posts/2020-02-07/macoxs-activity-monitory-column-is-missing/"/>
    <id>https://betacat.online/posts/2020-02-07/macoxs-activity-monitory-column-is-missing/</id>
    <published>2020-02-07T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.149Z</updated>
    
    <content type="html"><![CDATA[<p>MacOSX下的任务管理器出问题了。</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>MacOSX 最近系统升级后打开活动监视器，发现只有名称，别的信息都不见了。</p><p><img src="https://tobyqin.github.io/images/image-20200208153208904.png" alt="image-20200208153208904"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>其实原因是名称栏的布局被拉的很长，后面的列都在的但是被盖住了。用触摸板或者鼠标往右拉就可以看到了。然后再调整一下第一列的宽度就可以了。</p><p> 向右拉宽：</p><p><img src="https://tobyqin.github.io/images/2020-02/974c55f7-1b5d-47b7-9e4a-282304a727e0" alt="img"></p><p>再向右：</p><p><img src="https://tobyqin.github.io/images/2020-02/8e6eca08-1144-4773-88c3-463f36500b9a" alt="img"></p><p>出问题了：</p><p><img src="https://tobyqin.github.io/images/2020-02/5fcf74c5-8bf8-4fee-ad20-faeaa91218dd" alt="img"></p><p>重新归位：</p><p><img src="https://tobyqin.github.io/images/2020-02/961b27cf-00ea-4363-afbd-3760fbb64a9b" alt="img"></p><p>我印象中自己没调整过，应该是苹果升级系统后出的问题，他们的锅。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://discussionschinese.apple.com/thread/250913347" target="_blank" rel="noopener">https://discussionschinese.apple.com/thread/250913347</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MacOSX下的任务管理器出问题了。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="tips" scheme="https://betacat.online/tags/tips/"/>
    
      <category term="macosx" scheme="https://betacat.online/tags/macosx/"/>
    
  </entry>
  
  <entry>
    <title>蝙蝠</title>
    <link href="https://betacat.online/posts/2020-02-07/why-bat/"/>
    <id>https://betacat.online/posts/2020-02-07/why-bat/</id>
    <published>2020-02-07T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.141Z</updated>
    
    <content type="html"><![CDATA[<p>多年后孩子问：爸爸，为什么我们班里同学都是同年同一个月份的生日？爸爸看向远方，深沉的说：那得从一只蝙蝠说起……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多年后孩子问：爸爸，为什么我们班里同学都是同年同一个月份的生日？爸爸看向远方，深沉的说：那得从一只蝙蝠说起……&lt;/p&gt;

      
    
    </summary>
    
      <category term="Life" scheme="https://betacat.online/categories/life/"/>
    
    
      <category term="joke" scheme="https://betacat.online/tags/joke/"/>
    
  </entry>
  
  <entry>
    <title>一行代码停止或删除所有Docker容器</title>
    <link href="https://betacat.online/posts/2020-02-05/stop-remove-all-docker-containers/"/>
    <id>https://betacat.online/posts/2020-02-05/stop-remove-all-docker-containers/</id>
    <published>2020-02-05T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.185Z</updated>
    
    <content type="html"><![CDATA[<p>一行代码就可以停止或者删除所有的 <a href="http://www.docker.io/" target="_blank" rel="noopener">Docker</a> 容器。</p><a id="more"></a><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -a -q)</span><br><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一行代码就可以停止或者删除所有的 &lt;a href=&quot;http://www.docker.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker&lt;/a&gt; 容器。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="docker" scheme="https://betacat.online/tags/docker/"/>
    
      <category term="container" scheme="https://betacat.online/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>Linux 添加和删除 Swap 文件</title>
    <link href="https://betacat.online/posts/2020-02-02/add-and-delete-swap-files-under-linux/"/>
    <id>https://betacat.online/posts/2020-02-02/add-and-delete-swap-files-under-linux/</id>
    <published>2020-02-02T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.233Z</updated>
    
    <content type="html"><![CDATA[<p>Linux内核为了提高读写效率与速度，会将文件在内存中进行缓存，Swap 是通过磁盘文件的形式给系统增加虚拟内存的解决方案。</p><a id="more"></a><p>所以Swap速度肯定比真实内存慢，但是可以让系统可以处理超过自身内存瓶颈的任务。默认情况下，系统会用完物理内存后才用虚拟内存。</p><h2 id="检查-Swap"><a href="#检查-Swap" class="headerlink" title="检查 Swap"></a>检查 Swap</h2><p>先检查一下系统里有没有存在的 Swap 文件，如果返回的信息概要是空的，则表示 Swap 文件不存在。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon -s</span><br></pre></td></tr></table></figure><p>free命令可以确定swap文件是否在在使用。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure><h2 id="创建-Swap"><a href="#创建-Swap" class="headerlink" title="创建 Swap"></a>创建 Swap</h2><p>一般Swap文件的大小是内存的2倍，如果内存1G，Swap应该就是2G。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fallocate -l 2G /swapfile</span><br></pre></td></tr></table></figure><p>如果这个命令失败就用<code>dd</code>，但是需要计算字节数。  </p><blockquote><p>swap文件的大小单位为M。将该值乘以1024得到块大小。例如，64MB的swap文件的块大小是65536。</p></blockquote><p>下面使用 dd 命令来创建 Swap 文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1024 count=4194304</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>if=文件名：输入文件名，缺省为标准输入。即指定源文件。<code>&lt; if=input file &gt;</code></li><li>of=文件名：输出文件名，缺省为标准输出。即指定目的文件。<code>&lt; of=output file &gt;</code></li><li>bs=bytes：同时设置读入/输出的块大小为bytes个字节</li><li>count=blocks：仅拷贝blocks个块，块大小等于bs指定的字节数。</li></ul><p>最后，赋予 Swap 文件适当的权限：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown root:root /swapfile </span><br><span class="line">chmod 0600 /swapfile</span><br></pre></td></tr></table></figure><h2 id="激活-Swap"><a href="#激活-Swap" class="headerlink" title="激活 Swap"></a>激活 Swap</h2><p>创建好Swap文件，还需要格式化后才能使用。运行命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkswap /swapfile</span><br></pre></td></tr></table></figure><p>激活 Swap ，运行命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon /swapfile</span><br></pre></td></tr></table></figure><p>如果要机器重启的时候自动挂载 Swap ，那么还需要修改 fstab 配置。用 vim 打开 <code>/etc/fstab</code> 文件，在其最后添加如下一行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/swapfile   swap   swap    defaults 0 0</span><br></pre></td></tr></table></figure><p>当下一次系统启动时，新的swap文件就打开了。</p><p>在 Linux 系统中，可以通过查看 <code>/proc/sys/vm/swappiness</code> 内容的值来确定系统对 Swap 分区的使用原则。当 <code>swappiness</code> 内容的值为 0 时，表示最大限度地使用物理内存，物理内存使用完毕后，才会使用 Swap 分区。当 <code>swappiness</code> 内容的值为 100 时，表示积极地使用 Swap 分区，并且把内存中的数据及时地置换到 Swap 分区。 默认值为 0，表示需要在物理内存使用完毕后才会使用 Swap 分区。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看默认的swappiness参数 </span></span><br><span class="line">cat  /proc/sys/vm/swappiness </span><br><span class="line"><span class="comment">## 临时修改 </span></span><br><span class="line">sysctl -w  vm.swappiness=10 </span><br><span class="line"><span class="comment">## 永久修改 </span></span><br><span class="line">vi + /etc/sysctl.conf </span><br><span class="line"><span class="comment"># 添加 vm.swappiness=10 </span></span><br><span class="line"><span class="comment">## 让配置生效  sysctl -p</span></span><br></pre></td></tr></table></figure><h2 id="删除-Swap"><a href="#删除-Swap" class="headerlink" title="删除 Swap"></a>删除 Swap</h2><p>先卸载Swap分区，后从fastab中删除，最后删除文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapoff /swapfile</span><br><span class="line"><span class="comment"># remove swap configuration from /etc/fstab</span></span><br><span class="line">rm -rf /swapfile</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/wangjunjun2008/article/details/50681115" target="_blank" rel="noopener">https://blog.csdn.net/wangjunjun2008/article/details/50681115</a></li><li><a href="https://www.cnblogs.com/operationhome/p/10571166.html" target="_blank" rel="noopener">https://www.cnblogs.com/operationhome/p/10571166.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux内核为了提高读写效率与速度，会将文件在内存中进行缓存，Swap 是通过磁盘文件的形式给系统增加虚拟内存的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="linux" scheme="https://betacat.online/tags/linux/"/>
    
      <category term="swap" scheme="https://betacat.online/tags/swap/"/>
    
  </entry>
  
  <entry>
    <title>几种私有云盘解决方案</title>
    <link href="https://betacat.online/posts/2020-02-02/file-sever-and-private-cloud-solution/"/>
    <id>https://betacat.online/posts/2020-02-02/file-sever-and-private-cloud-solution/</id>
    <published>2020-02-02T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.121Z</updated>
    
    <content type="html"><![CDATA[<p>尝试了几种开源的私有云盘（文件服务器）的解决方案，备忘一下。</p><a id="more"></a><h2 id="Seafile"><a href="#Seafile" class="headerlink" title="Seafile"></a>Seafile</h2><p>可以参考<a href="https://cloud.seafile.com/published/seafile-manual-cn/docker" target="_blank" rel="noopener">官网部署文档</a>，最新版7.x需要用docker-compose，十分不推荐这种被淘汰的技术，所以还是用旧版（6.x）吧。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name seafile \</span><br><span class="line">  -e SEAFILE_SERVER_HOSTNAME=seafile.example.com \</span><br><span class="line">  -e SEAFILE_ADMIN_EMAIL=me@example.com \</span><br><span class="line">  -e SEAFILE_ADMIN_PASSWORD=a_very_secret_password \</span><br><span class="line">  -v /my/local/seafile-data:/shared \</span><br><span class="line">  -p 80:80 \</span><br><span class="line">  seafileltd/seafile:latest</span><br></pre></td></tr></table></figure><p>注意，<code>SEAFILE_SERVER_HOSTNAME</code> 一定要配置正确，不然上传文件会报网络错误，如果是本地测试可以配置成 127.0.0.1，默认的用户名密码如果没配的话，就是<code>me@example.com</code>，<code>asecret</code>。</p><p>如果一定要用7.x，可以尝试用<a href="https://hub.docker.com/r/tinysnake/seafile" target="_blank" rel="noopener">非官方封装的docker镜像</a>。</p><p>部署成功后就可以登录了，界面如下。</p><p><img src="https://tobyqin.github.io/images/seafile-example.png" alt="seafile-example"></p><p>Seafile可以映射本地目录，不过不会映射本地文件列表。也就是说，你不能直接操作本地文件然后在网页上体现，反之亦然。它映射的本地目录是按它的系统结构存储的数据，所以不是很方便，一定要映射本地某个目录的话就需要安装客户端了。</p><p>Seafile还提供了<a href="https://cloud.seafile.com/" target="_blank" rel="noopener">公有云的免费版和团队版</a>，2个G的容量随便用用还不错，不用自己部署和维护。</p><h2 id="filebrowser"><a href="#filebrowser" class="headerlink" title="filebrowser"></a>filebrowser</h2><p>这是一个挺简洁的文件管理器，不过项目在<a href="https://github.com/filebrowser/filebrowser" target="_blank" rel="noopener">Github</a>已经不维护了，挺可惜的，不过不影响使用。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name=filebrowser \</span><br><span class="line">    -v /path/to/your/files:/srv \</span><br><span class="line">    -v /data/filebrowser.db:/database.db \</span><br><span class="line">    -v /data/.filebrowser.json:/.filebrowser.json \</span><br><span class="line">    -p 80:80 \</span><br><span class="line">    filebrowser/filebrowser</span><br></pre></td></tr></table></figure><p>默认的用户名密码都是admin，-v 前半部分都是本地目录，按自己的情况修改，后半部分是容器里的目标目录，不能改。</p><p> 登录后的样子是这样的。</p><p><img src="https://tobyqin.github.io/images/filebrowser-example.png" alt="filebrowser-example"></p><p>作为文件管理器而言，它真的非常好用也很方便，整个镜像也很小，适合部署在任何服务器。而且它映射的文件目录中的文件会直接显示在网页上，操作文件是同步的。唯一的小缺点就是不能预览文件，所有文件类型都必须下载后才能查看。</p><h2 id="minio"><a href="#minio" class="headerlink" title="minio"></a>minio</h2><p>严格上来说，minio并不是一个文件管理器，而是一个功能完整的高性能存储对象服务，参见<a href="https://min.io/" target="_blank" rel="noopener">官网</a>。它提供了完整的存储对象API以及面向云原生设计，很方便部署在Kubernetes等云环境。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull minio&#x2F;minio</span><br><span class="line">docker run -p 9000:9000 minio&#x2F;minio server &#x2F;data</span><br></pre></td></tr></table></figure><p>默认的用户名密码都是minioadmin，在启动的控制台可以看到。界面非常简洁和清爽。</p><p><img src="https://tobyqin.github.io/images/minio-example.png" alt="minio-example"></p><h2 id="其他选择"><a href="#其他选择" class="headerlink" title="其他选择"></a>其他选择</h2><p>还有一些其他的可选方案，看上去不错，记下来权当备忘。</p><h3 id="蓝眼云盘"><a href="#蓝眼云盘" class="headerlink" title="蓝眼云盘"></a>蓝眼云盘</h3><p>Github：<a href="https://github.com/eyebluecn/tank" target="_blank" rel="noopener">https://github.com/eyebluecn/tank</a></p><p><img src="https://tobyqin.github.io/images/2020-02/tank0.png" alt="img"></p><h3 id="zdir"><a href="#zdir" class="headerlink" title="zdir"></a>zdir</h3><p>Github：<a href="https://github.com/helloxz/zdir" target="_blank" rel="noopener">https://github.com/helloxz/zdir</a><br><img src="https://tobyqin.github.io/images/2020-02/68747470733a2f2f696d6775726c2e6f72672f75706c6f61642f313830362f333439663362353430323864353864362e706e67" alt="img"></p><h3 id="caddy"><a href="#caddy" class="headerlink" title="caddy"></a>caddy</h3><p>Github：<a href="https://github.com/caddyserver/caddy" target="_blank" rel="noopener">https://github.com/caddyserver/caddy</a></p><p><img src="https://tobyqin.github.io/images/caddy-example.png" alt="caddy-example"></p><p>外加一些非开源的：</p><ul><li><a href="http://iscute.cn/chfs" target="_blank" rel="noopener">http://iscute.cn/chfs</a></li><li><a href="https://webd.cf/" target="_blank" rel="noopener">https://webd.cf/</a></li><li><a href="https://filelist.cn/public" target="_blank" rel="noopener">https://filelist.cn/public</a></li><li><a href="https://www.v2ex.com/t/553123" target="_blank" rel="noopener">https://www.v2ex.com/t/553123</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尝试了几种开源的私有云盘（文件服务器）的解决方案，备忘一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="seafile" scheme="https://betacat.online/tags/seafile/"/>
    
      <category term="file browser" scheme="https://betacat.online/tags/file-browser/"/>
    
      <category term="min.io" scheme="https://betacat.online/tags/min-io/"/>
    
      <category term="file server" scheme="https://betacat.online/tags/file-server/"/>
    
  </entry>
  
  <entry>
    <title>Library not loaded: /usr/local/opt/openssl@1.1/lib/libcrypto.1.1.dylib</title>
    <link href="https://betacat.online/posts/2020-01-30/dyld-libary-not-loaded-openssl-dylib/"/>
    <id>https://betacat.online/posts/2020-01-30/dyld-libary-not-loaded-openssl-dylib/</id>
    <published>2020-01-30T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.121Z</updated>
    
    <content type="html"><![CDATA[<p>因为升级了MacOSX和openssl，然后Jekyll和Python都坏了，报各种错误。</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Python和Git都会报错。</p><blockquote><p>dyld: Library not loaded: /usr/local/Cellar/python/3.7.3/Frameworks/Python.framework/Versions/3.7/Python<br>  Referenced from: /Users/tobyqin/src/service/venv/bin/python<br>  Reason: image not found</p><p>dyld: Library not loaded: /usr/local/opt/openssl@1.1/lib/libcrypto.1.1.dylib<br>Referenced from: /usr/local/bin/ssh<br>Reason: image not found<br>fatal: Could not read from remote repository. </p></blockquote><p>网上查了各种方案，头疼了好久。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>卸载新版的openssl，然后安装没有问题的openssl，python和jekyll就好了。</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade</span><br><span class="line">brew uninstall --ignore-dependencies openssl</span><br><span class="line">brew install https://github.com/tebelorg/Tump/releases/download/v1.0.0/openssl.rb</span><br></pre></td></tr></table></figure><p>但是，git和ssh却坏了。</p><p><strong>重新或者强制安装最新的openssh就好了</strong>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew reinstall openssh</span></span><br></pre></td></tr></table></figure><p>这时后python又坏了，因为它和openssh依赖的openssl版本不一致。</p><p>这时候需要切换默认的openssl版本，就可以解决所有问题。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew switch openssl 1.0.2t</span></span><br><span class="line">Cleaning /usr/local/Cellar/openssl/1.0.2t</span><br><span class="line">Opt link created for /usr/local/Cellar/openssl/1.0.2t</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为升级了MacOSX和openssl，然后Jekyll和Python都坏了，报各种错误。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="git" scheme="https://betacat.online/tags/git/"/>
    
      <category term="openssl" scheme="https://betacat.online/tags/openssl/"/>
    
      <category term="ssh" scheme="https://betacat.online/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>管理MacOSX的开机启动项</title>
    <link href="https://betacat.online/posts/2020-01-30/macosx-startup-items/"/>
    <id>https://betacat.online/posts/2020-01-30/macosx-startup-items/</id>
    <published>2020-01-30T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.173Z</updated>
    
    <content type="html"><![CDATA[<p>MacOSX下的开机项有多乱。</p><a id="more"></a><h2 id="系统偏好"><a href="#系统偏好" class="headerlink" title="系统偏好"></a>系统偏好</h2><p>在“系统偏好设置”窗口，选择“用户与群组”，进入用户与群组窗口。选择登录项选项卡，再解锁，最后删除开机启动的应用。</p><h2 id="plist-文件"><a href="#plist-文件" class="headerlink" title="plist 文件"></a>plist 文件</h2><p>分别在以下6个目录中检查是否有与开机程序相关的plist文件</p><ol><li>~/Library/Preferences/ – （当前用户设置的进程）</li><li>~/Library/LaunchAgents/ – （当前用户的守护进程）</li><li>/Library/LaunchAgents/ – （管理员设置的用户进程）</li><li>/Library/LaunchDaemons/ – （管理员提供的系统守护进程）</li><li>/System/Library/LaunchAgents/ – （Mac操作系统提供的用户进程）</li><li>/System/Library/LaunchDaemons/ – （Mac操作系统提供的系统守护进程）</li></ol><h3 id="plist中主要的字段和它的含义"><a href="#plist中主要的字段和它的含义" class="headerlink" title="plist中主要的字段和它的含义"></a>plist中主要的字段和它的含义</h3><ul><li><code>Label &lt;required, nsstring=“”&gt;</code> Launchd中的一个唯一标识，类似于每一个程序都有一个ID一样。</li><li><code>UserName &lt;optional, string=&quot;&quot;&gt;</code> 指定运行启动项的用户，只有当Launchd 作为 root 用户运行时，此项才适用。</li><li><code>GroupName &lt;optional, string=&quot;&quot;&gt;</code> 指定运行启动项的组，只有当Launchd 作为 root 用户运行时，此项才适用。</li><li><code>Program&lt;optional, string=&quot;&quot;&gt;</code> 这个值用来指定进程的可执行文件的路径。</li><li><code>ProgramArguments&lt;optional,array of=&quot;&quot; strings=&quot;&quot;&gt;</code> 如果未指定<code>Program</code>时就必须指定该项，包括可执行文件文件和运行的参数。</li><li><code>KeepAlive &lt;optional, boolean=&quot;&quot;&gt;</code> 用来控制可执行文件是持续运行，还是满足具体条件之后再启动。默认值为<code>false</code>，也就是说满足具体条件之后才启动。当设置值为<code>true</code>时，表明无条件的开启可执行文件，并使之保持在整个系统运行周期内。</li><li><code>RunAtLoad &lt;optional, boolean=&quot;”&gt;</code> 标识Launchd在加载完该项服务之后立即启动路径指定的可执行文件。默认值为<code>false</code>。</li><li><code>SuccessfulExit &lt;optional, boolean=&quot;”&gt;</code> 此项为 <code>true</code> 时，程序正常退出时重启（即退出码为 0）；为 <code>false</code> 时，程序非正常退出时重启。此项设置时会隐含默认 <code>RunAtLoad = true</code>，因为程序需要至少运行一次才能获得退出状态。</li></ul><p>所以不能简单的把以上目录中的plist删除来解决开机启动问题，这样会导致某些应用启动失败。最保险的办法是根据plist的文件名字，猜测它的作用，然后再配置其中的Key。</p><ul><li><p>如果 <code>KeepAlive</code> = false：</p></li><li><ul><li>当 <code>RunAtLoad</code> = false 时：程序只有在有需要的时候运行。</li><li>当 <code>RunAtLoad</code> = true 时：程序在启动时会运行一次，然后等待在有需要的时候运行。</li><li>当 <code>SuccessfulExit</code> =  true / false 时：不论 <code>RunAtLoad</code> 值是什么，都会在启动时运行一次。其后根据 <code>SuccessfulExit</code> 值来决定是否重启。 </li></ul></li><li><p>如果 <code>KeepAlive</code> = true ：</p></li><li><ul><li>不论 <code>RunAtLoad</code>/<code>SuccessfulExit</code> 值是什么，都会启动时运行且一直保持运行状态。</li></ul></li></ul><p>如果不希望开机自动运行，则需要：</p><blockquote><ol><li>找到对应程序的 .plist 文件 </li><li>删除 SuccessfulExit 属性。</li><li>将 RunAtLoad / KeepAlive 均设为 false</li></ol></blockquote><h2 id="StartupItems"><a href="#StartupItems" class="headerlink" title="StartupItems"></a>StartupItems</h2><p>StartupItems，顾名思义，就是在系统启动过程中运行的程序，它们可以是运行完就立即终止的程序，也可以是一直持续在系统运行周期的后台进程。</p><p>StartupItems 一般存放在以下两个路径下：</p><ol><li>/System/Library/StartupItems</li><li>/Library/StartupItems</li></ol><p>大部分与系统相关的StartupItems都放在<code>/System/Library/StartupItems</code>这个路径下，它们会先于 <code>/Library/StartupItems</code> 路径下的执行，因为前者路径下的StartupItems提供了系统级的基础服务，而后者路径在默认情况下是不存在的，需要自己手动创建。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://www.jianshu.com/p/542f6359f2d4" target="_blank" rel="noopener">https://www.jianshu.com/p/542f6359f2d4</a></li><li><a href="https://www.zhihu.com/question/28268529" target="_blank" rel="noopener">https://www.zhihu.com/question/28268529</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MacOSX下的开机项有多乱。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="macosx" scheme="https://betacat.online/tags/macosx/"/>
    
      <category term="startup" scheme="https://betacat.online/tags/startup/"/>
    
  </entry>
  
  <entry>
    <title>在Linux或者Mac OSX上查找大文件</title>
    <link href="https://betacat.online/posts/2020-01-29/search-large-files-on-linux/"/>
    <id>https://betacat.online/posts/2020-01-29/search-large-files-on-linux/</id>
    <published>2020-01-29T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.237Z</updated>
    
    <content type="html"><![CDATA[<p>在Mac OSX上尚且还有一些图形工具可以帮助查找和清理大文件，在Linux只能依靠命令行。其实也不难，这次总结一下，省的下次还去搜索。</p><a id="more"></a><h2 id="万能的du"><a href="#万能的du" class="headerlink" title="万能的du"></a>万能的du</h2><p><code>du</code> 是Linux和MacOSX都自带命令行工具，全称是 Disk Usage，这样就好记了。配合两个参数就可以搞定大多数问题。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-s      Display an entry for each specified file.  (Equivalent to -d 0)</span><br><span class="line">-h      "Human-readable" output.</span><br></pre></td></tr></table></figure><p><code>-s</code>的意思就是只统计第一层目录，<code>-h</code> 就是显示可读性的统计数据，看例子。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@2017127313 ~]# du -sh /*</span><br><span class="line">0       /bin</span><br><span class="line">89M     /boot</span><br><span class="line">0       /dev</span><br><span class="line">39M     /etc</span><br><span class="line">4.0K    /home</span><br><span class="line">16K     /lost+found</span><br><span class="line">4.0K    /media</span><br><span class="line">4.0K    /mnt</span><br><span class="line">4.0K    /opt</span><br><span class="line">0       /proc</span><br><span class="line">603M    /root</span><br><span class="line">13M     /run</span><br><span class="line">0       /sbin</span><br><span class="line">4.0K    /srv</span><br><span class="line">513M    /swapfile</span><br><span class="line">0       /sys</span><br><span class="line">616K    /tmp</span><br><span class="line">1.3G    /usr</span><br><span class="line">487M    /var</span><br></pre></td></tr></table></figure><p>从根目录开始找最大的目录，然后一层一层递进就可以找到占用最大空间的目录或者文件。</p><h3 id="限制数量和排序"><a href="#限制数量和排序" class="headerlink" title="限制数量和排序"></a>限制数量和排序</h3><p>当目录里文件比较多的时候，我们就要限制返回的条数和排序，比如我只想知道占用空间最大的5个目录，通过管道操作符就可以达到目的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@2017127313 ~]# du -s /usr/* | sort -nr | head -5</span><br><span class="line">598904  /usr/lib</span><br><span class="line">303676  /usr/share</span><br><span class="line">185836  /usr/lib64</span><br><span class="line">124044  /usr/bin</span><br><span class="line">44772   /usr/sbin</span><br></pre></td></tr></table></figure><h2 id="当前目录占用空间"><a href="#当前目录占用空间" class="headerlink" title="当前目录占用空间"></a>当前目录占用空间</h2><p><code>du</code> 还可以很方便检查当前目录占用空间。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@2017127313 ~]<span class="comment"># du -sh</span></span><br><span class="line">603M    .</span><br></pre></td></tr></table></figure><h2 id="比较难记的find"><a href="#比较难记的find" class="headerlink" title="比较难记的find"></a>比较难记的find</h2><p><code>find</code> 是非常强大的命令，可以按文件属性进行搜索，比如检索大于10M的文件。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@50KVM-2017127313 ~]<span class="comment"># find . -size +10M</span></span><br><span class="line">./blog/.git/objects/pack/pack-fab187cef1cd08d186624f1e5e97e3131b20abc0.pack</span><br><span class="line">./docs/.git/objects/3f/3385a6b098631a8426a720dcd56a9ed7da4183</span><br><span class="line">./docs/PPT/Demo.pptx</span><br></pre></td></tr></table></figure><p>如上命令是把文件名打印出来了，但文件的细节还是不清楚，这时候你需要加上更多参数。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find / -size +500M -<span class="built_in">exec</span> du -h &#123;&#125; \; 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>如果还要排序，再加个管道。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -size +100M  -print0 | xargs -0 du -h | sort -nr</span><br></pre></td></tr></table></figure><p><code>find</code> 权当是备忘吧，具体的参数我是记不住的，推荐还是用简单易懂的<code>du</code>。</p><h2 id="额外的df"><a href="#额外的df" class="headerlink" title="额外的df"></a>额外的df</h2><p><code>df</code>也是磁盘管理常用的工具之一，全称不知道是什么，从文档上看好像是 Disk space available on file system? 需要记住的参数只有一个，就是<code>-h</code>，可读性显示。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@2017127313 ~]# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        107M     0  107M   0% /dev</span><br><span class="line">tmpfs           117M     0  117M   0% /dev/shm</span><br><span class="line">tmpfs           117M   13M  105M  11% /run</span><br><span class="line">tmpfs           117M     0  117M   0% /sys/fs/cgroup</span><br><span class="line">/dev/vda1       4.9G  3.0G  1.7G  65% /</span><br><span class="line">tmpfs            24M     0   24M   0% /run/user/0</span><br></pre></td></tr></table></figure><p>这个命令就是用来看磁盘剩余空间的，当然有时候 <code>-ai</code>的参数也偶尔会被提到，用来检查<code>inode</code>的使用情况。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@017127313 ~]# df -ai</span><br><span class="line">Filesystem     Inodes IUsed  IFree IUse% Mounted on</span><br><span class="line">devtmpfs        27317   393  26924    2% /dev</span><br><span class="line">tmpfs           29942     1  29941    1% /dev/shm</span><br><span class="line">tmpfs           29942   491  29451    2% /run</span><br><span class="line">tmpfs           29942    16  29926    1% /sys/fs/cgroup</span><br><span class="line">/dev/vda1      324480 50300 274180   16% /</span><br><span class="line">tmpfs           29942     2  29940    1% /run/user/0</span><br></pre></td></tr></table></figure><p>如果<code>inode</code>占用到100%了，你的磁盘就是还有空间也写不进去了，<code>inode</code>可以理解为文件的索引区吧，用来存放文件的属性等等，具体的内容会写到 <code>block</code> 区，当文件很碎的时候，<code>block</code> 可能还没满，但是 <code>inode</code>已经满了。</p><h2 id="免费赠送的-free"><a href="#免费赠送的-free" class="headerlink" title="免费赠送的 free"></a>免费赠送的 free</h2><p>文章的最后再送个 <code>free</code> 命令吧，这个跟文件系统有一丢丢关系，这个命令是用来显示内存的。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@2017127313 ~]<span class="comment"># free -h</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           233M         58M         28M          9M        147M        142M</span><br><span class="line">Swap:          511M         21M        490M</span><br></pre></td></tr></table></figure><p><code>free</code> 是用来显示内存占用情况的，<code>-h</code> 一样是人性化显示。注意，这个命令还是看到swap分区的使用情况。</p><p>一般Linux都会配置虚拟内存，也就是用swap分区。很早以前内存还是很宝贵的，所以聪明的人类就划分了一部分硬盘来充当二级内存，纵然速度慢点，但是容量更大了能处理的东西就更多了。</p><p><code>free</code> 里可以查看swap占用情况，但不能清理或者调整它的大小。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Mac OSX上尚且还有一些图形工具可以帮助查找和清理大文件，在Linux只能依靠命令行。其实也不难，这次总结一下，省的下次还去搜索。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="tips" scheme="https://betacat.online/tags/tips/"/>
    
      <category term="linux" scheme="https://betacat.online/tags/linux/"/>
    
      <category term="du" scheme="https://betacat.online/tags/du/"/>
    
  </entry>
  
  <entry>
    <title>组织Flask项目结构</title>
    <link href="https://betacat.online/posts/2020-01-25/the-flask-project-structure/"/>
    <id>https://betacat.online/posts/2020-01-25/the-flask-project-structure/</id>
    <published>2020-01-25T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.129Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tobyqin.github.io/images/organizing.png" alt="organizing"></p><p><a href="https://palletsprojects.com/p/flask/" target="_blank" rel="noopener">Flask</a> 是非常轻量和灵活的Python框架，轻量和灵活是它的优点，也是它的缺点。所以我们在使用Flask构建项目时就不得不慎重考虑其目录结构，以便日后扩展和维护。</p><a id="more"></a><p>这里我列举了一些常见的Flask项目结构，没有好坏之分，大家可以按照实际情况参考使用。</p><h2 id="极简风格"><a href="#极简风格" class="headerlink" title="极简风格"></a>极简风格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.py</span><br><span class="line">config.py</span><br><span class="line">requirements.txt</span><br><span class="line">static&#x2F;</span><br><span class="line">templates&#x2F;</span><br></pre></td></tr></table></figure><p>此项目结构可以用于构建最简单的Web程序，一般用于Demo或者POC。</p><h2 id="使用App组织项目"><a href="#使用App组织项目" class="headerlink" title="使用App组织项目"></a>使用App组织项目</h2><p>相对复杂的项目可以按包（package）的方式来组织代码，不同的包对应不同的应用（app），每个应用相对独立，其中会有自治的视图（view）和模型（model）等等。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.py</span><br><span class="line">requirements.txt</span><br><span class="line">run.py</span><br><span class="line">instance&#x2F;</span><br><span class="line">    config.py</span><br><span class="line">yourapp&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    views.py</span><br><span class="line">    models.py</span><br><span class="line">    forms.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">    templates&#x2F;</span><br></pre></td></tr></table></figure><p>其实Flask项目做到这个程度已经差不多了，如果项目再复杂，就不太推荐使用Flask了，而是考虑换成<a href="https://www.djangoproject.com/" target="_blank" rel="noopener">django</a>或者其他更适合做大型项目的框架，死磕Flask最后只会适得其反。</p><p>欲知更多，可参考:</p><ul><li><a href="http://exploreflask.com/en/latest/organizing.html" target="_blank" rel="noopener">http://exploreflask.com/en/latest/organizing.html</a></li><li><a href="https://lepture.com/en/2018/structure-of-a-flask-project" target="_blank" rel="noopener">https://lepture.com/en/2018/structure-of-a-flask-project</a></li><li><a href="http://flask.pocoo.org/docs/1.0/patterns/packages/" target="_blank" rel="noopener">http://flask.pocoo.org/docs/1.0/patterns/packages/</a></li><li><a href="https://www.digitalocean.com/community/tutorials/how-to-structure-large-flask-applications" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-structure-large-flask-applications</a></li></ul><h2 id="使用Blueprints组织项目"><a href="#使用Blueprints组织项目" class="headerlink" title="使用Blueprints组织项目"></a>使用Blueprints组织项目</h2><p>更加复杂的项目可以引入 <a href="http://docs.jinkan.org/docs/flask/blueprints.html" target="_blank" rel="noopener">Blueprints</a> 来简化工作，这是官方推荐的Flask大型项目解决方案。一个 Blueprints 对象和一个 Flask 对象很类似，所以有了Blueprints 之后你可以很方便的将大型应用拆分成多个子项目来开发和加载。Blueprints需要注册后才能被加载，有点像插件。</p><p>Blueprints 解决了应用拆分的可能性，但怎么拆分和组合还是开发者的事情，下面几个例子可以参考一下。</p><h3 id="基于逻辑功能"><a href="#基于逻辑功能" class="headerlink" title="基于逻辑功能"></a>基于逻辑功能</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yourapp&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">        home&#x2F;</span><br><span class="line">        control_panel&#x2F;</span><br><span class="line">        admin&#x2F;</span><br><span class="line">    views&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">        home.py</span><br><span class="line">        control_panel.py</span><br><span class="line">        admin.py</span><br><span class="line">    models.py</span><br><span class="line">tests&#x2F;</span><br></pre></td></tr></table></figure><h3 id="基于职能模块"><a href="#基于职能模块" class="headerlink" title="基于职能模块"></a>基于职能模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.txt</span><br><span class="line">requirements.txt</span><br><span class="line">run.py</span><br><span class="line">yourapp&#x2F;</span><br><span class="line">  __init__.py</span><br><span class="line">  home&#x2F;</span><br><span class="line">    views.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">  dash&#x2F;</span><br><span class="line">    views.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">  admin&#x2F;</span><br><span class="line">    views.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">  api&#x2F;</span><br><span class="line">    views.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">  blog&#x2F;</span><br><span class="line">    views.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">    templates&#x2F;</span><br><span class="line">  models.py</span><br><span class="line">tests&#x2F;</span><br></pre></td></tr></table></figure><h3 id="静态模板的组织"><a href="#静态模板的组织" class="headerlink" title="静态模板的组织"></a>静态模板的组织</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">facebook&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    templates&#x2F;</span><br><span class="line">        layout.html</span><br><span class="line">        home&#x2F;</span><br><span class="line">            layout.html</span><br><span class="line">            index.html</span><br><span class="line">            about.html</span><br><span class="line">            signup.html</span><br><span class="line">            login.html</span><br><span class="line">        dashboard&#x2F;</span><br><span class="line">            layout.html</span><br><span class="line">            news_feed.html</span><br><span class="line">            welcome.html</span><br><span class="line">            find_friends.html</span><br><span class="line">        profile&#x2F;</span><br><span class="line">            layout.html</span><br><span class="line">            timeline.html</span><br><span class="line">            about.html</span><br><span class="line">            photos.html</span><br><span class="line">            friends.html</span><br><span class="line">            edit.html</span><br><span class="line">        settings&#x2F;</span><br><span class="line">            layout.html</span><br><span class="line">            privacy.html</span><br><span class="line">            security.html</span><br><span class="line">            general.html</span><br><span class="line">    views&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">        home.py</span><br><span class="line">        dashboard.py</span><br><span class="line">        profile.py</span><br><span class="line">        settings.py</span><br><span class="line">    static&#x2F;</span><br><span class="line">        style.css</span><br><span class="line">        logo.png</span><br><span class="line">    models.py</span><br></pre></td></tr></table></figure><p>对于Flask应用中的静态模板，我觉得在现代应用中还需要三思。因为大多数的现代应用都会考虑用nodejs构建前端，使用模板语言已经属于异教徒，后期的维护和更新更是挖坑填坑的过程。</p><h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>对于要快速见效的项目，用Flask还是不错的选择，例如做个页面收集数据或者展示图表，再或者模拟几个API用于测试等等。但是大点的项目还是算了吧，真的，不骗你，要填的坑远比你想象的多的多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://tobyqin.github.io/images/organizing.png&quot; alt=&quot;organizing&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://palletsprojects.com/p/flask/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask&lt;/a&gt; 是非常轻量和灵活的Python框架，轻量和灵活是它的优点，也是它的缺点。所以我们在使用Flask构建项目时就不得不慎重考虑其目录结构，以便日后扩展和维护。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="python" scheme="https://betacat.online/tags/python/"/>
    
      <category term="flask" scheme="https://betacat.online/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>Bash 脚本中的 set -euxo pipefail</title>
    <link href="https://betacat.online/posts/2020-01-06/bash-scripts-with-set-euxo-pipefail/"/>
    <id>https://betacat.online/posts/2020-01-06/bash-scripts-with-set-euxo-pipefail/</id>
    <published>2020-01-06T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.205Z</updated>
    
    <content type="html"><![CDATA[<p>有些开发人员会用Bash来实现很复杂的功能，就像使用别的高级语言一样。他可能觉得自己很牛逼但其他人早就想锤爆他了，Bash的可读性和可维护性远远低于任何高级语言。更要命的是，Bash并没有方便的调试工具和防错机制，出了问题你要排查半天。</p><a id="more"></a><p>在Ruby或者Python等高级语言里，你很容易知道错误是哪行什么类型的错误，还有IDE的Debugger加持。而Bash只能看源码，通过打印log等非常低效的方式调试。</p><p>本文将介绍Bash中 <code>set -euxo pipefail</code>，它们可以帮助你写出更容易维护也更安全的脚本。这也是Bash脚本的终极调试手段，希望你以后在自己的脚本中加上这么一行，头顶也能少秃一点。</p><h2 id="set-e"><a href="#set-e" class="headerlink" title="set -e"></a>set -e</h2><p><code>set -e</code> 选项可以让你的脚本在出现异常时马上退出，后续命令不再执行。默认情况下Shell脚本不会因为错误而结束执行，但大多数情况是，我们希望出现异常时就不要再往下走了。假如你的<code>if</code>判断条件里会出现异常，这时脚本也会直接退出，但可能这并不是你期望的情况，这时你可以在判断语句后加上 <code>|| true</code> 来阻止退出。</p><h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 'foo' is a non-existing command</span></span><br><span class="line">foo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment"># line 4: foo: command not found</span></span><br><span class="line"><span class="comment"># bar</span></span><br></pre></td></tr></table></figure><h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'foo' is a non-existing command</span></span><br><span class="line">foo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment"># line 5: foo: command not found</span></span><br></pre></td></tr></table></figure><p>阻止立即退出的例子。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'foo' is a non-existing command</span></span><br><span class="line">foo || <span class="literal">true</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment"># line 5: foo: command not found</span></span><br><span class="line"><span class="comment"># bar</span></span><br></pre></td></tr></table></figure><h2 id="set-o-pipefail"><a href="#set-o-pipefail" class="headerlink" title="set -o pipefail"></a>set -o pipefail</h2><p>默认情况下Bash只会检查管道（pipeline）操作最后一个命令的返回值，假如最右边的命令成功那么它就认为这个语句没问题。这个行为其实是很不安全的，所以就有了<code>set -o pipefail</code>。这个特别的选项表示在管道连接的命令中，只要有任何一个命令失败（返回值非0），则整个管道操作被视为失败。只有管道中所有命令都成功执行了这个管道才算成功执行。</p><h3 id="Before-1"><a href="#Before-1" class="headerlink" title="Before"></a>Before</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'foo' is a non-existing command</span></span><br><span class="line">foo | <span class="built_in">echo</span> <span class="string">"a"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment"># a</span></span><br><span class="line"><span class="comment"># line 5: foo: command not found</span></span><br><span class="line"><span class="comment"># bar</span></span><br></pre></td></tr></table></figure><h3 id="After-1"><a href="#After-1" class="headerlink" title="After"></a>After</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -eo pipefail</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'foo' is a non-existing command</span></span><br><span class="line">foo | <span class="built_in">echo</span> <span class="string">"a"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment"># a</span></span><br><span class="line"><span class="comment"># line 5: foo: command not found</span></span><br></pre></td></tr></table></figure><h2 id="set-u"><a href="#set-u" class="headerlink" title="set -u"></a>set -u</h2><p><code>set -u</code> 比较容易理解，Bash会把所有未定义的变量视为错误。默认情况下Bash会将未定义的变量视为空，不会报错，这也是很多坑的来源。也许由于变量名的细微差别让你查半天最后骂骂咧咧。</p><h3 id="Before-2"><a href="#Before-2" class="headerlink" title="Before"></a>Before</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -eo pipefail</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># bar</span></span><br></pre></td></tr></table></figure><h3 id="After-2"><a href="#After-2" class="headerlink" title="After"></a>After</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -euo pipefail</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment"># line 5: a: unbound variable</span></span><br></pre></td></tr></table></figure><h2 id="set-x"><a href="#set-x" class="headerlink" title="set -x"></a>set -x</h2><p><code>set -x</code> 可以让Bash把每个命令在执行前先打印出来，你可以认为这就是Bash的Debug开关。它的好处当然显而易见，方便你快速找到有问题的脚本位置，但是也坏处也有吧，就是Bash的log会格外的乱。另外，它在打印命令前会把变量先解析出来，所以你可以知道当前执行的语句的变量值是什么。纵然log可能会乱一些，总比头发乱一些好，所以建议还是打开这个开关。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -euxo pipefail</span><br><span class="line"></span><br><span class="line">a=5</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"bar"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment"># ------</span></span><br><span class="line"><span class="comment"># + a=5</span></span><br><span class="line"><span class="comment"># + echo 5</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># + echo bar</span></span><br><span class="line"><span class="comment"># bar</span></span><br></pre></td></tr></table></figure><p>以上就是关于 <code>set -euxo pipefail</code> 的介绍，从Shell脚本的编写角度看，我十分建议所有人都应该在自己的Shell脚本里加上这么一行。但从实际情况看，如果你的Shell脚本已经超过200行，我更建议你换成高级语言来实现。比如Python或者Ruby甚至Perl，这些高级语言在Linux系统都是内置的，注意版本兼容性就好，写起来比Shell舒服太多了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些开发人员会用Bash来实现很复杂的功能，就像使用别的高级语言一样。他可能觉得自己很牛逼但其他人早就想锤爆他了，Bash的可读性和可维护性远远低于任何高级语言。更要命的是，Bash并没有方便的调试工具和防错机制，出了问题你要排查半天。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="https://betacat.online/categories/tech/"/>
    
    
      <category term="bash" scheme="https://betacat.online/tags/bash/"/>
    
      <category term="shell" scheme="https://betacat.online/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>谢谢，我们很忙</title>
    <link href="https://betacat.online/posts/2019-12-31/thanks-we-are-busy/"/>
    <id>https://betacat.online/posts/2019-12-31/thanks-we-are-busy/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2020-11-25T03:16:34.113Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tobyqin.github.io/images/too-busy-to-improve.png" alt="too-busy-to-improve"></p><p>新的一年开始了，</p><p>不要为了忙碌而忙碌。</p><p>在忙碌中找问题，</p><p>多用脑子，避免老年痴呆。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://tobyqin.github.io/images/too-busy-to-improve.png&quot; alt=&quot;too-busy-to-improve&quot;&gt;&lt;/p&gt;
&lt;p&gt;新的一年开始了，&lt;/p&gt;
&lt;p&gt;不要为了忙碌而忙碌。&lt;/p&gt;
&lt;p&gt;在
      
    
    </summary>
    
      <category term="Life" scheme="https://betacat.online/categories/life/"/>
    
    
      <category term="comics" scheme="https://betacat.online/tags/comics/"/>
    
      <category term="geek" scheme="https://betacat.online/tags/geek/"/>
    
  </entry>
  
</feed>
